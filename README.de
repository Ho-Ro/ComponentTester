
------------------------------------------------------------------------------

            ReadMe für die Component-Tester-Firmware (m-Firmware)

        (c) 2012-2021 by Markus Reschke (madires@theca-tabellaria.de)

------------------------------------------------------------------------------

Letzte Änderung: 2021-03-12

Inhaltsübersicht:
  - Über den Tester
  - Sicherheitshinweise
  - Lizenz
    - Zusätzliche Hinweise
  - Unterschiede zur k-Firmware
  - Quellcode
  - Unterstützte Hardware
  - Firmware übersetzen
  - Busse & Schnittstellen
    - I2C/SPI
    - Serielle TTL-Schnittstelle
    - OneWire
  - Anzeige-Module
    - HD44780
    - ILI9163
    - ILI9341/ILI9342
    - ILI9481
    - ILI9486
    - ILI9488
    - PCD8544
    - PCF8814
    - SH1106
    - SSD1306
    - ST7036
    - ST7565R
    - ST7735
    - ST7920
    - STE2007/HX1230
    - VT100 Terminal
  - Tasten und Eingabeoptionen
    - Test-Taste
    - Drehencoder
    - Mehr/Weniger-Tasten
    - Touch-Screen
  - Benutzerschnittstelle
  - Kommunikation mit PC
    - Serielle Ausgabe
    - Automatisierung
    - VT100-Ausgabe
  - Einschalten
  - Bauteilesuche
  - Batterieüberwachung
  - Ausschalten
  - Menü
    - PWM-Generator
    - Rechteck-Signalgenerator
    - Zenertest
    - ESR-Tool
    - Kondensatorleckstrom
    - R/C/L-Monitore
    - L/C-Meter
    - Frequenzzähler
      - Einfacher Zähler
      - Erweiterter Zähler
    - Ereigniszähler
      - Triggerausgang
    - Drehencoder
    - Kontrast
    - Detektor/Decoder für IR-Fernbedienungen
    - IR-Fernbedienung
    - Opto-Koppler-Test
    - Modellbau-Servo-Test
    - OneWire-Scan
    - DS18B20-Temperatursensor
    - DHTxx-Sensoren
    - Selbsttest
    - Selbstabgleich
    - Speichern/Laden
    - Werte anzeigen
    - Ausschalten
    - Exit
  - Widerstände
  - Kondensatoren
  - Induktivitäten
  - Bauteile entladen
  - ADC Oversampling
  - Ergebnisanzeige
    - Zusätzliche Hinweise
      - Bipolartransistoren
      - TRIACs
      - CLDs
  - Nicht unterstütze Bauelemente
  - Abhilfen für manche Tester
  - Bekannte Probleme
  - Hilfe
  - Firmware-Änderungen
  - Fernsteuerungskommandos
  - Hilfreiche Links
  - Quellenverzeichnis


* Über den Tester

Der Component Tester basiert auf dem Projekt von Markus Frejek [1&2] und der
Weiterführung von Karl-Heinz Kübbeler [3&4]. Es ist eine alternative
Firmware für die aktuelle Testerschaltung von Karl-Heinz und bietet einige
Änderungen der Benutzerschnittstelle und Mess- und Testverfahren. Auch gibt
es zusätzliche Funktionen. Während die Firmware von Karl-Heinz die offizielle
Version ist und auch ältere ATmega-MCUs unterstützt, benötigt diese Version
einen ATmega mit mindestens 32kB Flash.

Hinweis: Bitte den Selbstabgleich bei brandneuen Testern oder nach Firmware-
aktualisierung laufen lassen. Oder auch bei Benutzung anderer Messkabel.


* Sicherheitshinweise

Der Component Tester ist kein Multimeter! Es ist ein einfacher Tester für
Bauteile, der Verschiedenes messen kann. Die Eingänge sind nicht geschützt
und werden durch Spannungen über 5V beschädigt. Den Tester nicht für
Schaltungen in Betrieb nutzen, sondern nur für einzelne Bauteile! Bei
Kondensatoren darauf achten, daß sie entladen sind, bevor der Tester
angeklemmt wird. Benutzung auf eigene Gefahr!


* Lizenz

Der Autor der Ursprungsversion hat bzgl. der Lizenzbedingungen nur zwei
Vorgaben gemacht. Zum einen ist das Projekt Open Source, und zum anderen
sollen sich kommerzielle Benutzer beim Autor melden. Unglücklicherweise
haben wir, Karl-Heinz und ich, den Autor bisher nicht erreichen können.
Um das Problem des Fehlens einer vernünftigen Open-Source-Lizenz zu lösen,
habe ich am 1.1.2016 eine Standard-Open-Source-Lizenz ausgewählt, nachdem
der ursprüngliche Autor ausreichend zeit hatte uns seine Wünsche bzgl. einer
Lizenz mitzuteilen. Da diese Firmwareversion eine komplett neue Version ist,
die lediglich ein paar Ideen der ursprünglichen Firmware aufgreift, aber
keinen Code teilt, sollte dieses Vorgehen gerechtfertigt sein. 

Lizenziert unter der EUPL V.1.1


+ Zusätzliche Hinweise

Produkt- oder Firmennamen können geschützte Marken der jeweiligen Eigentümer
sein.


* Unterschiede zur k-Firmware

Karl-Heinz hat eine richtig gute Doumentation für den Tester geschrieben.
Unbedingt lesen! Daher zähle ich nur die Hauptunterschiede zur k-Firmware auf:

- Benutzerschnittstelle
  + Keine Panik! ;)
  + Touch Screen
  + Automatisierung (Fernsteuerkommandos)
- Adaptive Entladefunktion
- Widerstandsmessung
  + zusätliche Methode für Widerstände <10 Ohm (anstatt ESR-Messung)
- Kapazitätsmessung
  + ab 5pF
  + zusätzliche Methode für Kondensatoren zwischen 4,7µF und 47µF
  + anderes Verfahren zur Korrektur/Kompensation
- kein SamplingADC() für sehr niedrige Kapazitäten oder Induktivitäten
- Dioden
  + Erkennungslogik
- Bipolartransistoren
  + V_f wird für praxisnahe Testströme interpoliert
  + Erkennung von Germanium-Transistoren mit höherem Leckstrom
  + Erkennung von Schottky-Transistoren
- JFETs
  + Erkennung von JFETs mit sehr niedrigem I_DSS
- TRIACs
  + Erkennung von MT1 und MT2
- Detektor/Dekoder für IR-Fernsteuerungen
- IR-Fernbedienung
- Test von Opto-Kopplern
- Test von Modellbau-Servos
- OneWire (DS18B20)
- DHTxx-Sensoren
- Ereigniszähler
- Strukturierter Quellcode
- Und Manches mehr, was mir gerade nicht einfällt.

Mehr Details dazu findest Du in den nachfolgenden Abschnitten.


* Quellcode

Die erste m-Firmware basierte auf dem Quellcode von Karl-Heinz. Eine Menge
wurde aufgeräumt, Kommentare, Variablen umbenannt, Funktionen umstrukturiert,
große Funktionen in mehrere kleine aufgeteilt und mehr. Danach entwickelte
sich die m-Firmware immer weiter zu einer eigenständigen Version. Es sind
u.A. einfache Frameworks für Anzeige und Schnittstellen dazu gekommen. Ich
hoffe, daß der Quellcode einfach zu lesen und gut verständlich ist.

Du findest die aktuelle Firmware auf folgenden Webseiten:
- https://github.com/Mikrocontroller-net/transistortester/tree/master/Software/Markus
- https://github.com/madires/Transistortester-Warehouse


* Unterstützte Hardware

Die Firmware läuft auf allen Testern, die zur Grundschaltung in Karl-Heinz's
Dokumentation kompatibel sind und eine der folgenden MCUs nutzen:
  - ATmega 328
  - ATmega 324/644/1284
  - ATmega 640/1280/2560

Anpassungen an unterschiedliche Pin-Belegungen sind möglich. Als Anzeige kann
man Text- oder Grafikdisplays (monochrom oder farbig) nutzen. Für die unter-
stützen Controller bitte den Abschnitt "Anzeige-Module" konsultieren.

Folgende Hardware-Optionen werden unterstützt:

  Bedienung
  - Drehimpulsgeber
  - zusätzliche Tasten (mehr/weniger)
  - Touch-Screen
  - serielle Schnittstelle (TTL, RS232, USB-Seriell-Adapter)

  Verbesserungen
  - externe Spannungsreferenz 2,5V
  - fester Abgleichkondensator
  - Schutz-Relais zum Entladen von Kondensatoren

  zusätzliche Tests und Messungen
  - Zener-Test / Messung einer externen Spannung <50V
  - einfacher Frequenzzähler
  - erweiterter Frequenzzähler
    mit Vorteiler und Quarzoszillatoren für niedrige und hohe Frequenzen 
  - fester IR-RC-Empfänger


* Firmware übersetzen

Als erstes solltest Du das Makefile editieren und MCU-Modell, Frequenz,
Oszillator-Typ und die Programmieradaptereinstellungen anpassen. Alle anderen
Einstellungen stehen in der globalen config.h und einer MCU-spezifischen
config-<MCU>.h. In der Datei "Clones" findest Du Einstellungen zu
verschiedenen Testerversionen bzw. Clonen. Ist Dein Tester nicht dabei,
schicke bitte die Einstellungen per EMail an den Autor, um anderen Benutzern
damit zu helfen.

In config.h wähle Hardware- und Software-Optionen, die Sprache für die
Bedienung, und ändere Standardwerte, wenn notwendig. Alle Einstellungen und
Werte sind in der Datei selber erklärt. Daher folgt hier nur eine kurze
Übersicht der wichtigsten Punkte.

Hardware-Optionen:
- zusätzliche Tasten bzw. Eingabeoptionen
  - Drehencoder
  - Mehr/Weniger-Tasten
  - Touch-Screen
- externe 2,5V Spannungsreferenz
- Schutz-Relais zur Kondensatorentladung
- Messung von Zenerdioden (DC-DC-Konverter)
- Frequenzzähler (einfache und erweiterte Version)
- Ereigniszähler
- LC-Meter
- Test von IR-Fernbedienungen (festes IR-Empfängermodul)
- fester Kondensator für Selbstabgleich von Spannungsoffsets
- SPI-Bus (Bit-Bang und Hardware)
- I2C-Bus (Bit-Bang und Hardware)
- TTL-Serielle (Bit-Bang und Hardware)
- OneWire Bus (Bit-Bang)

Die externe 2,5V Spannungsreferenz sollte nur genutzt werden, wenn sie
um den Faktor 10 genauer als der Spannungsregler ist. Ansonsten würde
sie die Messergebnisse eher verschlechtern als verbessern. Wenn Du einen
MCP1702 mit einer typischen Genauigkeit von 0,4% als Spannungsregler
hast, brauchst Du eigentlich keine zusätzliche Spannungsreferenz mehr.

Und natürlich die Software-Optionen:
- PWM Generator (2 Varianten)
- Messung von Induktivität
- ESR-Messung und In-Circuit ESR
- Test von Drehencodern
- Rechtecksignalgenerator (braucht zusätzliche Tasten)
- Test von IR-Fernbedienungen (IR-Empfängermodul an Testpins)
- IR-Fernbedienung (IR-LED mit Treibertransistor)
- Test von Opto-Kopplern
- Test von Modellbau-Servos (braucht zusätzliche Tasten, Display >2 Zeilen)
- Erkennung von UJTs
- Test für Kondensatorleckstrom
- DS18B20 Temperatursensor
- Farbkodierung für Testpins (benötigt Farbdisplay)
- Ausgabe der gefundenen Bauteile parallel über TTL-Serielle, z.B auf PC
- Fernsteuerkommandos über TTL-Serielle.
- Ausgabe des umgekehrten hFE (C & E verdreht) für Bipolartransistoren
- DHT11/22 Temperatur- und Luftfeuchtigkeitssensor
- ...

Bitte die Optionen entprechend Deinen Wünschen und den begrenzten Ressourcen 
der MCU, d.h. RAM, EEPROM und Flash-Speicher, auswählen. Sollte die Firmware
zu groß werden, versuche für Dich nicht so wichtige Optionen wieder zu
deaktivieren.

Verfügbare Sprachen:
- Dänisch
  - von glenndk@mikrocontroller.net
  - benötigt kleine Änderungen im Font
- Deutsch
- Englisch
- Italienisch
  - von Gino_09@EEVblog
- Polnisch
  - von Szpila
- Romänisch
  - von Dumidan@EEVblog
- Russisch
  - von indman@EEVblog
  - Zeichensatz mit kyrillischen Zeichen basierend auf Windows-1251
- Russisch 2
  - von hapless@EEVblog
  - Zeichensatz mit kyrillischen Zeichen basierend auf Windows-1251
- Spanisch
  - von pepe10000@EEVblog
- Tschechisch
  - von Kapa
  - Zeichensatz basierend auf ISO 8859-1
- Tschechisch 2
  - von Bohu
  - Zeichensatz mit tschechischen Zeichen basierend auf ISO 8859-2

Bei Zahlenwerten werden die Dezimalstellen standardmäßig durch einen Punkt
gekennzeichnet, kann aber auf Komma umgestellt werden.

Für die MCU-spezifischen Einstellungen, wie Pin-Zuordnungen und Display,
editiere config_<MCU>.h:
- ATmega 328                config_328.h
- ATmega 324/644/1284       config_644.h
- ATmega 640/1280/2560      config_1280.h

Das Anzeige-Modul sollte min. 2 Zeilen mit min. 16 Zeichen haben. Für
Grafikmodule einen Zeichensatz wählen, der die obige Bedingung erfüllt.

Nach dem Editieren vom Makefile, config.h und config-<MCU>.h bitte "make"
ausführen oder Dein IDE, um die Firmware zu übersetzen.
Als Ergebnis werden zwei Dateien erzeugt:
- ComponentTester.hex   Firmware im Intel-Hex-Format
- ComponentTester.eep   EEPROM-Daten im Intel-Hex-Format

Die Firmware wird in das Flash geschrieben und die EEPROM-Daten in das EEPROM.
Die Daten enthalten zwei Sätze an Standardabgleichswerten, Texte und Tabellen.
Wenn Du bei der Aktualsierung der Firmware die alten Abgleichswerte im EEPROM
beibehalten möchtest, kann Du mit dem Schalter DATA_FLASH in config.h die
Texte und Tabellen in die Firmware verschieben. In diesem Fall muss dann nur
die Firmware in das Flash geschrieben werden; das EEPROM bleibt unverändert.  

Das Makefile bietet folgende zusätzliche Targets: 
- clean     alle Objektdateien löschen
- fuses     Fuse-Bits setzen (via avrdude)
- upload    Firmware und EEPROM-Daten brennen (via avrdude)
- prog_fw   nur Firmware brennen (via avrdude)
- prog_ee   nur EEPROM-Daten brennen (via avrdude)


* Busse & Schnittstellen


+ I2C/SPI

Manche LCD-Module and andere Komponenten benötigen I2C oder SPI als Schnitt-
stelle zur MCU. Daher hat der Firmware Treiber für beide Bussysteme. Um
unterschiedliche Beschaltungen zu unterstützen haben die Bustreiber einen
Bit-Bang und einen Hardware-Modus. Beim Bit-Bang-Modus können beliebige IO
Pins an dem gleichen Port genutzt werden, während der Hardware-Modus die
fest vorgegeben Bus-Pins der MCU nimmt. Der Nachteil des Bit-Bang-Modus ist
seine Geschwindigkeit, er ist langsam. Der Hardware-Modus dagegen ist deutlich
schneller. Du kannst den Unterschied leicht bei Farb-LCD-Modulen mit hoher
Auflösung sehen.

Für Tester mit ATmega 328 wird fast immer der Bit-Bang-Modus aufgrund der
Beschaltung benötigt. Der ATmega 324/644/1284 hat mehr I/O Pins, plus die
veränderte Beschaltung erlauben es, die festen Bus-Pins für den Hardware-
Modus zu nutzen. 

Da SPI oder I2C primär vom LCD-Modul genutzt wird, können beide im Abschnitt
fuer LCD-Module in config-<MCU>.h direkt konfiguriert werden. Alternativ kannst
Du auch I2C bzw. SPI in config.h aktivieren und Ports & Pins in config-<MCU>.h
festlegen (schaue nach I2C_PORT bzw. SPI_PORT).

Falls Du Bit-Bang-SPI plus Lese-Modus (SPI_RW) auswählst, bitte darauf achten
auch SPI_PIN und SPI_MISO zu setzen. Beispiele dazu findest Du im Abschnitt
zu SPI in config-<MCU>.h.


+ Serielle TTL-Schnittstelle

Der Tester kann auch eine optionale serielle TTL-Schnittstelle haben. Wird
diese zur Kommunikation mit einem PC genutzt, sollte sie mit einem USB-zu-TTL
Konverter oder einem RS-232 Treiberbaustein kombiniert werden. Die Firmware
kann den UART der MCU oder einen Software-UART (Bit-Bang) nutzen. Die TTL-
Serielle wird in config.h aktiviert (siehe Abschnitt "Busses"), und Port & Pins
sind in config-<MCU>.h definiert (schaue nach SERIAL_PORT).

Der Software-UART hat den Nachteil, daß das TX-Signal nicht ständig "high"
ist, wenn die Schnittstelle ruht. Ursache dafür ist benutze Methode wie
Port-Pins angesteuert werden. Ein Umschreiben der Ansteuerung würde die
Firmware deutlich vergrößern. Dieses Problem scheint aber keine Auswirkung
auf die meisten USB-zu-TTL Konverter zu haben. Sollte es doch Probleme
geben, kannst Du einen Pull-up-Widerstand (10-100k) am TX-Pin probieren, um
den Signalpegel im Ruhemodus auf "high" zu halten. 

Die Standardeinstellung der seriellen Schnittstele ist 9600 8N1:
  - 9600 bps
  - 8 Datenbits
  - keine Parität
  - 1 Stopbit
  - keine Flussteuerung


+ OneWire

Ein weiterer unterstützter Bus ist OneWire, welcher entweder die Test-Pins (
ONEWIRE_PROBES) oder einen festen MCU-Pin (ONEWIRE_IO_PIN) benutzen kann.
Der Treiber ist für Standard-Busgeschwindigkeit und Clients mit externer
Stromversorgung (nicht parasitär versorgt) ausgelegt.

Beschaltung von Test-Pins:
  Probe #1:  Gnd
  Probe #2:  DQ (Daten)
  Probe #3:  Vcc (Strom durch 680 Ohm Widerstand begrenzt)
  Ein externer Pull-Up-Widerstand von 4,7kOhm zwischen DQ and Vcc wird
  benötigt!

Funktionen, die genau einen Client am Bus erfordern, können optional den ROM-
Code des Clients ausgeben (ONEWIRE_READ_ROM). Im Fall eines CRC-Fehlers oder
wenn mehrere Clients am Bus hängen, ist die Ausgabe "-". Ist der komplette
ROM-Code Null, besteht ein Lesefehler. Ansonsten zeigt der erste Teil des
ROM-Codes die Produktfamilie und der zweite Teil die Seriennummer.


* Anzeige-Module

Im Augenblick werden folgende Controller unterstützt:
- HD44780 (textbasiertes Display, 2-4 Zeilen mit je 16-20 Zeichen)
- ILI9163 (grafisches Farb-Display 128x160)
- ILI9341/ILI9342 (grafisches Farb-Display 240x320 oder 320x240)
- ILI9481 (grafisches Farb-Display 320x480, teilweise ungetestet)
- ILI9486 (grafisches Farb-Display 320x480, teilweise ungetestet)
- ILI9488 (grafisches Farb-Display 320x480, teilweise ungetestet)
- PCD8544 (grafisches Display 84x48)
- PCF8814 (grafisches Display 96x65)
- SH1106 (grafisches Display 128x64)
- SSD1306 (grafisches Display 128x64)
- ST7036 (textbasiertes Display, 3 Zeilen mit je 16 Zeichen, ungetestet)
- ST7565R (grafisches Display 128x64)
- ST7735 (grafisches Farb-Display 128x160)
- ST7920 (grafisches Display bis zu 256x64)
- STE2007/HX1230 (grafisches Display 96x68)
- VT100 Terminal (über serielle Schnitstelle)

Beachte die Versorgungsspannung und die Logikpegel des Anzeige-Moduls! Benutze
Pegelumsetzer, sofern notwendig. Ein einfacher Pegelumsetzer mit Widerständen
in Reihe unter Ausnutzung der internen Begrenzungsdioden des Anzeige-
Controllers kann funktionieren, aber nur für langsame Busse, wie z.B. Bit-Bang
SPI. Daher empfehle ich, Pegelumsetzer-ICs zu verwenden. 

Falls Du IO-Pins einsparen möchtest, kannst Du bei fast allen Anzeige-Modulen
/CS und /RES per Pullup/Pulldown-Widerstände fest verdrahten und die
entsprechenden IO-Pins in der Konfiguration (config_<MCU>.h) auskommentieren,
solange das Anzeige-Modul allein am Bus hängt.

Wenn das Display trotz korrekter Beschaltung nichts anzeigt, versuche den
Kontrast zu ändern (config_<MCU>.h).

Grafik-Anzeigen haben meistens Einstellmöglichkeiten für die Orientierung der
Ausgabe, z.B. Bild um 90° rotieren, Bild horizontal spiegeln oder auch
vertikal. Damit läßt sich das Bild an den jeweiligen Tester anpassen. Für
grafische Farbanzeigen gibt es zusätzliche Einstellungen. Im normalen Farbmodus
werden mehrere Farben verwendet, die mittels der Datei colors.h änderbar sind.
Durch Auskommentieren von LCD_COLOR wird der Zwei-Farb-Modus aktiviert. Die
Schriftfarbe ist dann COLOR_PEN und die Hintergrundfarbe COLOR_BACKGROUND.  
Sollten die RGB-Grundfarben Rot und Blau vertauscht sein, kannst Du per LCD_BGR
die entsprechenden Farbkanäle tauschen. Bei manchen Anzeigen ist die
Reihenfolge der RGB-Unterpixel verdreht und der Controller weiss nichts davon.

Hinweis zu ATmega 328:
Wenn Du einen Drehencoder an PD2/PD3 hängst, dann verbinde /CS vom Anzeige-
Modul mit PD5 und setze LCD_CS in config_328.h (nur für grafische Anzeige-
Module). Anderenfalls würde der Drehencoder den Datenbus durcheinander bringen
und zu fehlerhaften Ausgaben führen.


+ HD44780

Der HD44780 wird im 4-Bit-Modus bestrieben. Die Pins für den Parallelbus sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  DB4         LCD_DB4          PD0
  DB5         LCD_DB5          PD1
  DB6         LCD_DB6          PD2
  DB7         LCD_DB7          PD3
  RS          LCD_RS           PD4
  R/W                          Gnd
  E           LCD_EN1          PD5

Das LCD-Modul kann auch über einen I2C-Adapter mit PCF8574 bestrieben werden.
Dazu muss zum einen I2C aktiviert werden, und zum anderen wird auch die
I2C-Adresse des PCF8574 benötigt. Das Pinout beschreibt wie das LCD-Modul mit
dem PCF8574 verdrahtet ist:

  Modul       config-<MCU>.h   Standard     Hinweis
  ---------------------------------------------------------------
  DB4         LCD_DB4          PCF8574_P4
  DB5         LCD_DB5          PCF8574_P5
  DB6         LCD_DB6          PCF8574_P6
  DB7         LCD_DB7          PCF8574_P7
  RS          LCD_RS           PCF8574_P0
  R/W         LCD_RW           PCF8574_P1
  E           LCD_EN1          PCF8574_P2
  LED         LCD_LED          PCF8574_P3


+ ILI9163

Der ILI9163 wird mittels 4-Draht-SPI gesteuert. Die Pins sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RESX       LCD_RES          PD4          optional
  /CSX        LCD_CS           PD5          optional
  D/CX        LCD_DC           PD3
  SCL         LCD_SCL          PD2          SPI Clock
  SDIO        LCD_SDA          PD1          SPI MOSI

Für eine korrekte Anzeige mußt Du evtl. mit den Einstellungen X/Y-Flip
experimentieren. Bei Bedarf kannst Du auch die X-Richtung verschieben. Wenn
LCD_LATE_ON aktiviert ist, startet der Tester mit einem gelöschten Display,
was zu einer kurzen Verzögerung beim Einschalten führt. Ansonsten sind beim
Anschalten kurz zufällige Pixel zu sehen.


+ ILI9341/ILI9342

Der ILI9341/ILI9342 wird mittels 4-Line-SPI oder 8-Bit-Parallel gesteuert. Die
Pins für 4-Line-SPI sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RES          PD4          optional
  /CS         LCD_CS           PD5          optional
  D/C         LCD_DC           PD3
  SCK         LCD_SCK          PD2          SPI Clock
  SDI         LCD_SDI          PD1          SPI MOSI
  SDO         LCD_SDO          -            nur ILI9341, noch nicht benutzt

Das Pinout für 8-Bit-Parallel ist:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 2560
  ---------------------------------------------------------------
              LCD_PORT         PORTB
  /RESX       LCD_RES          PB4          optional
  /CSX        LCD_CS           PB5          optional
  D/CX        LCD_DC           PB7
  WRX         LCD_WR           PB0
  RDX         LCD_RD           PB6          optional
              LCD_PORT2        PORTL
  D0          LCD_DB0          PL0          LCD_PORT2 Pin #0
  D1          LCD_DB1          PL1          LCD_PORT2 Pin #1
  D2          LCD_DB2          PL2          LCD_PORT2 Pin #2
  D3          LCD_DB3          PL3          LCD_PORT2 Pin #3
  D4          LCD_DB4          PL4          LCD_PORT2 Pin #4
  D5          LCD_DB5          PL5          LCD_PORT2 Pin #5
  D6          LCD_DB6          PL6          LCD_PORT2 Pin #6
  D7          LCD_DB7          PL7          LCD_PORT2 Pin #7

Für eine korrekte Anzeige mußt Du evtl. mit den Einstellungen X/Y-Flip und
Rotate experimentieren. Und nicht vergessen, die X und Y-Auflösung korrekt
zu setzen (ILI9341 ist 240x320 und ILI9342 ist 320x240). Manche Anzeigemodule
haben den erweiterten Befehlssatz des ILI9341 deaktiviert (EXTC-Pin liegt auf
Masse), und die Ausgabe ist dann oft nur schemenhaft. Das läßt sich per
LCD_EXT_CMD_OFF korrigieren.

Aufgrund der hohen Pixelzahl ist die Ausgabe per SPI etwas langsam. Das
Löschen der kompletten Anzeige dauert etwa 3 Sekunden bei Bit-Bang-SPI
und 8MHz MCU-Takt. Besser Hardware-SPI oder den Parallel-Bus nutzen.


+ ILI9481 (teilweise ungetestet)

Der ILI9481 wird per 8-Bit-Parallel oder 16-Bit-Parallel gesteuert.

Das Pinout für 8-Bit-Parallel ist:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 2560
  ---------------------------------------------------------------
              LCD_PORT         PORTB
  /RESX       LCD_RES          PB4          optional
  /CSX        LCD_CS           PB5          optional
  D/CX        LCD_DC           PB7
  WRX         LCD_WR           PB0
  RDX         LCD_RD           PB6          optional
              LCD_PORT2        PORTL
  DB0         LCD_DB0          PL0          LCD_PORT2 Pin #0
  DB1         LCD_DB1          PL1          LCD_PORT2 Pin #1
  DB2         LCD_DB2          PL2          LCD_PORT2 Pin #2
  DB3         LCD_DB3          PL3          LCD_PORT2 Pin #3
  DB4         LCD_DB4          PL4          LCD_PORT2 Pin #4
  DB5         LCD_DB5          PL5          LCD_PORT2 Pin #5
  DB6         LCD_DB6          PL6          LCD_PORT2 Pin #6
  DB7         LCD_DB7          PL7          LCD_PORT2 Pin #7


Die Pin-Belegung für 16-Bit-Parallel ist die gleiche wie bei 8-Bit-Parallel
plus zusätzlich:

              LCD_PORT3        PORTC
  DB8         LCD_DB8          PC0          LCD_PORT3 Pin #0
  DB9         LCD_DB9          PC1          LCD_PORT3 Pin #1
  DB10        LCD_DB10         PC2          LCD_PORT3 Pin #2
  DB11        LCD_DB11         PC3          LCD_PORT3 Pin #3
  DB12        LCD_DB12         PC4          LCD_PORT3 Pin #4
  DB13        LCD_DB13         PC5          LCD_PORT3 Pin #5
  DB14        LCD_DB14         PC6          LCD_PORT3 Pin #6
  DB15        LCD_DB15         PC7          LCD_PORT3 Pin #7

Üblicherweise muß die Anzeige für die korrekte Darstellung rotiert werden (
LCD_ROTATE). Falls nötig, kannst Du die auch X und/oder Y umdrehen. 


+ ILI9486 (teilweise ungetestet)

Der ILI9486 wird per 8-Bit-Parallel oder 16-Bit-Parallel gesteuert. Und er
benutzt die gleiche Pin-Belegung wie der ILI9481.


+ ILI9488 (teilweise ungetestet)

Der ILI9488 wird per 8-Bit-Parallel oder 16-Bit-Parallel gesteuert. Und er
benutzt die gleiche Pin-Belegung wie der ILI9481. Zusätzlich wird 4-Draht-SPI
unterstützt:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 644
  ---------------------------------------------------------------
  /RES        LCD_RES          PB2          optional
  /CS         LCD_CS           PB5          optional
  D/C         LCD_DC           PB3
  SCL         LCD_SCL          PB7          SPI Clock
  SDA         LCD_SDA          PB5          SPI MOSI

Wegen der hohen Auflösung der Anzeige und dem RGB666-Farbschema (3 Bytes pro
Pixel) ist SPI recht langsam, selbst für Hardware-SPI und einen
16MHz-MCU-Takt. Daher rate ich von der Nutzung der SPI-Schnittstelle ab.


+ PCD8544

Der PCD8544 wird mittels SPI gesteuert. Die Pins sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RES          PD4          optional
  /SCE        LCD_SCE          PD5          optional
  D/C         LCD_DC           PD3
  SCLK        LCD_SCLK         PD2          SPI Clock
  SDIN        LCD_SDIN         PD1          SPI MOSI

Da das Display nur 84 Punkte in X-Richtung hat, ergeben sich max. 14 Zeichen
pro Zeile bei einem 6x8-Zeichensatz. Also werden bis zu zwei Zeichen
verschluckt. Wenn das stört, kannst Du in variables.h die Texte etwas kürzen.


+ PCF8814

Der PCF8814 wird typischerweise per 3-Draht-SPI gesteuert. Die Pins für
3-Draht-SPI sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RESET        PD4
  /CS         LCD_CS           PD5          optional
  SCLK        LCD_SCLK         PD2          SPI Clock
  SDIN        LCD_SDIN         PD1          SPI MOSI

Bei Bedarf kann die Ausgabe über die Y-Flip-Einstellung und den MX-Pin (X-Flip)
des PCF8814 (Pull-Up/Down) rotiert werden.


+ SH1106 (teilweise ungetestet)

Der SH1106 wird mittels 3-Line-SPI, 4-Line-SPI oder I2C gesteuert. 3-Line-SPI
benötigt den Bit-Bang-Modus, und SPI_9 muss aktiviert sein. Die Pins für
4-Line-SPI sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RESET        PD4          optional
  /CS         LCD_CS           PD5          optional
  A0          LCD_A0           PD3
  SCL (D0)    LCD_SCL          PD2          SPI Clock
  SI (D1)     LCD_SI           PD1          SPI MOSI

Für 3-Line-SPI (nur Bit-Bang):

  /RES        LCD_RESET        PD4          optional
  /CS         LCD_CS           PD5          optional
  A0                           Gnd
  SCL (D0)    LCD_SCL          PD2          SPI Clock
  SI (D1)     LCD_SI           PD1          SPI MOSI

Und für I2C:

  /RES        LCD_RESET        PD4          optional
  /CS                          Gnd
  SCL (D0)    I2C_SCL          PD1
  SDA (D1)    I2C_SDA          PD0
  SA0 (A0)                     Gnd (0x3c) / 3.3V (0x3d)

Mit den X/Y-Flip Einstellungen kannst Du die Orientierung der Anzeige
anpassen, wenn notwenig. Bei vielen SH1106-Display-Modulen muss der X-Offset
auf 2 gesetzt werden. 


+ SSD1306

Der SSD1306 wird mittels 3-Line-SPI, 4-Line-SPI oder I2C gesteuert. 3-Line-SPI
benötigt den Bit-Bang-Modus, und SPI_9 muss aktiviert sein. Die Pins für
4-Line-SPI sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RESET        PD4          optional
  /CS         LCD_CS           PD5          optional
  DC          LCD_DC           PD3
  SCLK (D0)   LCD_SCLK         PD2          SPI Clock
  SDIN (D1)   LCD_SDIN         PD1          SPI MOSI

Für 3-Line-SPI (nur Bit-Bang):

  /RES        LCD_RESET        PD4          optional
  /CS         LCD_CS           PD5          optional
  SCLK (D0)   LCD_SCLK         PD2          SPI Clock
  SDIN (D1)   LCD_SDIN         PD1          SPI MOSI

Und für I2C:

  /RES        LCD_RESET        PD4          optional
  SCL (D0)    I2C_SCL          PD1
  SDA (D1&2)  I2C_SDA          PD0
  SA0 (D/C)                    Gnd (0x3c) / 3.3V (0x3d)

Mit den X/Y-Flip Einstellungen kannst Du die Orientierung der Anzeige
anpassen, wenn notwenig.


+ ST7036 (ungetestet)

Der ST7036 wird per 4-bit-Parallel-Schnittstelle oder 4-Draht-SPI angesprochen.
Die Pins für die 4-bit-Parallel-Schnittstelle sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  DB4         LCD_DB4          PD0
  DB5         LCD_DB5          PD1
  DB6         LCD_DB6          PD2
  DB7         LCD_DB7          PD3
  RS          LCD_RS           PD4
  R/W                          Gnd          optional LCD_RW
  E           LCD_EN           PD5
  XRESET                       Vcc          optional LCD_RESET

Und für 4-Draht-SPI:

  XRESET      LCD_RESET        PD4          optional
  CSB         LCD_CS           PD5          optional
  RS          LCD_RS           PD3
  SCL (DB6)   LCD_SCL          PD2          SPI Clock
  SI (DB7)    LCD_SI           PD1          SPI MOSI

Der ST7036i spricht I2C, wird aber (noch) nicht unterstützt. Ein spezielles
Merkmal des ST7036 ist ein Pin zum Aktivieren eines erweiterten Befehlsatzes (
Pin EXT), welcher bei den meisten Modulen eingeschaltet ist. Sollte er
abgeschaltet sein, sind die Einstellungen LCD_EXTENDED_CMD und LCD_CONTRAST
auszukommentieren.


+ ST7565R

Der ST7565R wird mittels 4-Line-SPI gesteuert. Die Pins sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RESET        PD0          optional
  /CS1        LCD_CS           PD5          optional
  A0          LCD_A0           PD1
  SCL (DB6)   LCD_SCL          PD2          SPI Clock
  SI (DB7)    LCD_SI           PD3          SPI MOSI

Für eine korrekte Anzeige mußt Du evtl. mit den Einstellungen X/Y-Flip und
X-Offset experimentieren.


+ ST7735

Der ST7735 wird mittels 4-Line-SPI gesteuert. Die Pins sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RESX       LCD_RES          PD4          optional
  /CSX        LCD_CS           PD5          optional
  D/CX        LCD_DC           PD3
  SCL         LCD_SCL          PD2          SPI Clock
  SDA         LCD_SDA          PD1          SPI MOSI

Für eine korrekte Anzeige mußt Du evtl. mit den Einstellungen X/Y-Flip
experimentieren. Wenn LCD_LATE_ON aktiviert ist, startet der Tester mit einem
gelöschten Display, was zu einer kurzen Verzögerung beim Einschalten führt.
Ansonsten sind beim Anschalten kurz zufällige Pixel zu sehen.

Es ist inzwischen auch ein teil-kompatibles LCD-Modul aufgetaucht, welches
nicht mit dem normalen Treiber funktioniert. Als Lösung gibt es einen
modifizierten Treiber (LCD_SEMI_ST7735 anstatt LCD_ST7735) mit den gleichen
Einstellmöglichkeiten.


+ ST7920

Der ST7920 kann per 4-bit-Parallel-Modus oder SPI gesteuert werden. Die Pins
für den Parallelbus sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /XRESET     LCD_RESET        Vcc          optional
  E           LCD_EN           PD5
  RS          LCD_RS           PD4
  RW          LCD_RW           Gnd          optional
  D4          LCD_DB4          PD0
  D5          LCD_DB5          PD1
  D6          LCD_DB6          PD2
  D7          LCD_DB7          PD3

Und für SPI:

 /XRESET      LCD_RESET        PD4          optional
 CS (RS)      LCD_CS           PD5          optional
 SCLK (E)     LCD_SCLK         PD2          SPI Clock
 SID (RW)     LCD_SID          PD1          SPI MOSI

Wegen dem schlechten Design des ST7920 können nur Zeichensätze mit einer Breite
von 8 Pixeln verwendet werden. Zur Handhabung der horizontalen Addressierung in
16-Bit Schritten mußte ich einen Bildschirmpuffer für Zeichen einrichten.


+ STE2007/HX1230

Der STE2007 wird typischerweise per 3-Draht-SPI gesteuert. Die Pins für 3-Draht-SPI 
sind:

  Modul       config-<MCU>.h   Standard     Hinweis
                               ATmega 328
  ---------------------------------------------------------------
  /RES        LCD_RESET        PD4          optional
  /CS         LCD_CS           PD5          optional
  SCLK        LCD_SCLK         PD2          SPI Clock
  SDIN        LCD_SDIN         PD1          SPI MOSI

Falls nötig, kannst Du die Ausgabe über die X/Y-Flip-Einstellungen rotieren.


+ VT100 Terminal

Der VT100-Treiber ersetzt ein LCD-Modul, und die komplette Ausgabe erfolgt über
ein serielles VT100-Terminal. Der Konfigrationsabschnitt für VT100 aktiviert
die serielle Schnittstelle gleich mit. Bitte beachte, daß der VT100-Treiber
andere Optionen für die serielle Schnittstelle deaktiviert, welche die Ausgabe
beeinträchtigen können.


* Tasten und Eingabeoptionen

Der Tester wird über primär über die Test-Taste bedient, erlaubt aber
zusätzliche Eingabeoptionen, welche die Bedienung erleichtern oder für
manche Funktion auch notwendig sind.


+ Test-Taste

Die Test-Taste schaltet den Tester ein und dient zur Bedienung. Dazu
unterscheidet der Tester zwischen einem kurzen Tastendruck und einem langen (
0,3s). Der kurze Tastendruck wird üblicherweise zum Fortfahren einer Funktion
oder zur Auswahl des nächsten Menüpunktes benutzt. Der lange Tastendruck führt
eine kontextabhängige Aktion aus.

Wenn der Tester einen Tastendruck zum Fortfahren der aktuellen Aktion erwartet,
zeigt es dies durch einen Cursor rechts unten auf dem LCD-Modul an. Ein
statischer Cursor signalisiert, daß weitere Informationen folgen, und ein
blinkender Cursor bedeutet, daß mit der Bauteilesuche weiter gemacht wird.
Für Menüs und einige Extrafunktionen wird der Cursor nicht angezeigt, da die
erwartete Eingabe hier klar sein sollte. 

Optional kannst du Bedienungshinweise einschalten, sofern dein Tester
zusätzliche Eingabeoptionen und eine Anzeige mit ausreichend vielen Textzeilen
hat (siehe UI_KEY_HINTS in config.h). Dann zeigt der Tester eine Bedienungs-
hilfe statt des Cursors an, falls eine vorhanden ist. Im Augenblick gibt es
nur eine solche Hilfe für die Bauteilesuche (Menü/Test).


+ Drehencoder (Hardware-Option)

Mit einem Drehencoder erhält die Bedienung zusätzliche Funktionalität, die
kontextabhängig ist. Die Details werden in den weiteren Abschnitten erklärt.
Manche Funktionen erlauben über die Drehgeschwindigkeit größere Änderungen
oder Sprünge von Werten. 

Der Lese-Algorithmus berücksichtigt die Anzahl der Gray-Code-Pulse pro
Schritt (ENCODER_PULSES) und auch die Anzahl der Schritte für eine volle
360 Grad Umdrehung (ENCODER_STEPS). Mit dem letzteren Wert kannst Du
auch eine Feineinstellung der Erkennung der Drehgeschwindigkeit vornehmen.
Ein höherer Wert verlangsamt die Drehgeschwindigkeit, ein niedriger Wert
erhöht sie. Sollte die Drehrichtung verkehrt herum sein, einfach die Pin-
Definitionen für A und B in config_<MCU>.h vertauschen.

Die Erkennung der Drehgeschwindigkeit mißt die Zeit von zwei Schritten. Also
solltest Du den Encoder mindestens um zwei Schritte für mittlere
Gewindigkeiten drehen. Für höhere Geschwindigkeiten sind es drei Schritte.
Ein einzelner Schritt resultiert immer in der niedrigsten Geschwindigkeit. 


+ Mehr/Weniger-Tasten (Hardware-Option)

Wenn Dir Tasten lieber als ein Drekencoder sind, dann kannst Du alternativ
auch zwei Tasten nutzen. Die Tasten werden genauso wie ein Drehencoder
angeschlossen (Pull-Up Widerstände, Logikpegel Low bei Betätigung). Für
eine Beschleunigung, ähnlich der Drehgeschwindikeit beim Drehencoder, einfach
die Taste lange drücken. Je länger, desto höher wird die Beschleunigung.


+ Touch-Screen (Hardware-Option)

Als weitere Eingabeoption ist ein Touch-Screen möglich. Dazu sollte das
LCD-Modul groß genug sein und mindestens 8 Textzeilen je 16 Zeichen oder mehr
unterstützen. Um wertvollen Platz auf dem LCD zu sparen, verzichten wir auf
Symbole zum Berühren. Stattdessen gibt es unsichtbare Leisten links und rechts
(je 3 Zeichen breit), oben und unten (je 2 Zeilen hoch) und eine Fläche in der
Mitte. Die Leisten links und oben sind für "weniger" oder "Menüpunkt hoch",
rechts und unten entsprechend für "mehr" oder "Menüpunkt runter". Also die
gleiche Funktion wie beim Drehencoder. Ein langes Berühren beschleunigt
Änderungen in manchen Funktionen, ähnlich der Drehgeschwindigkeit beim Dreh-
encoder. Die Fläche in der Mitte ist eine Software-Version der Test-Taste,
sie kann aber z.B. nicht die Zener-Test-Option mit Strom versorgen.

Für die Benutzung des Touch-Screen ist ein Abgleich notwendig. Dieser wird
automatisch nach dem Einschalten des Testers gestartet, wenn noch keine
Abgleichwerte im EEPROM gespeichert sind. Man kann ihn auch über das Haupt-
menü starten. Die Prozedur ist recht einfach. Wenn Du ein Sternchen (gelbes *
bei Farb-LCDs) siehst, drauf drücken. Danach löscht der Tester das Sternchen
und zeigt die native x/y-Position an. Der erste Abgleichspunkt ist oben rechts,
und der zweite unten links. Je nach Ergebnis wiederholt der Tester den Abgleich
bis zu dreimal. Den Abgleich kannst Du aber jeder Zeit mit der Test-Taste
abbrechen.

Wenn Du Probleme mit dem Abgleich, wie z.B. falsche x/y-Positionen oder einen
Fehler nach der ersten Abgleichsrunde, hast, überprüfe bitte die Orientierung
des Touch-Screen zum LCD-Modul. Der Treiber hat Schalter zum Verdrehen und
Vertauschen der Orientierung. Oben links wird als Nullpunkt angenommen.
Hinweise zu den benötigten Einstellungen je nach x/y-Werten:

  Erster Abgleichspunkt: oben rechts

  x        y        Einstellung
  -----------------------------------------
  niedrig  niedrig  TOUCH_FLIP_X
  niedrig  hoch     TOUCH_FLIP_X & TOUCH_FLIP_Y
  hoch     niedrig  keine
  hoch     hoch     TOUCH_FLIP_Y

Nach einem erfolgreichen Abgleich nicht vergessen, die Offset-Werte zu
speichen (Hauptmenü: Speichern).

Unterstützte Touch-Screen-Controller:
- ADS7843 / XPT2046

Du findest die Konfiguration dazu unterhalb des Bereichs für LCD-Module in
config-<MCU>.h (momentan nur config_644.h und config_1280.h, da der 328 zu
wenig unbenutze IO-Pins hat).


* Benutzerschnittstelle

Es gibt mehrere Optionen, die Display-Ausgabe für Anzeigen schicker oder
verständlicher zu gestalten.

Für Anzeigen mit mehr als zwei Textzeilen:
- Anzeige von Tastenhinweisen statt Cursor, sofern verfügbar (UI_KEY_HINTS)

Für graphische Anzeigen:
- alle vorherigen Optionen
- Symbole mit Pinout für dreibeinige Halbleiter (SW_SYMBOLS, nicht für
  Anzeigen mit niedriger Auflösung)

Für farbige Grafikanzeigen:
- alle vorherigen Optionen
- Farbcodierung für Testpins (UI_PROBE_COLORS)
- Titel mit eigener Farbe (UI_COLORED_TITLES)
- Cursor und Tastenhinweise mit eigener Farbe (UI_COLORED_CURSOR)
- Farbcode für Widerstände (SW_R_E24_5_CC, SW_R_E24_1_CC und SW_R_E96_CC)


* Kommunikation mit PC

Der Tester kann eine serielle TTL-Schnittstelle zur Kommunilkation mit einem
PC nutzen. Dies kann eine unidrektionale Verbindung (nur Senden) zur seriellen
Ausgabe von gefundenen Bauteilen sein, oder auch eine bidrektionale zur
Automatisierung. In beiden Fällen muß die serielle Schnittstelle aktiviert
werden (siehe Abschnitt "Busses" in config.h).

Spezielle Zeichen werden durch Standardzeichen ersetzt, z.B. wird das Omega (
Ohm) zu einem R.

Konvertierungstabelle:
  Diodensymbol        |>  <|
  Kondensatorsymbol   ||
  Omega               R
  micro / µ           u
  Widerstandssymbol   []

Hinweise:
- 9600 8N1
- Newline ist <CR><LF>


+ Serielle Ausgabe

Der Tester gibt gefundene Bauteile zusätzlich über die serielle Schnitt-
stelle aus, wenn dies aktviert ist (siehe UI_SERIAL_COPY im Abschnitt "misc
settings" in config.h). Dazu reicht ein einfaches Terminalprogramm auf dem PC. 
Die Ausgabe folgt der Ausgabe auf dem LCD-Display, aber nur für gefundene
Bauteile.  Es erfolgt keine Ausgabe von Menüs und Funtionen über
die Serielle, außer für Ergebnisse vom Opto-Koppler-Test.


+  Automatisierung

Die Automatisierung ermöglicht die Fernsteuerung des Testers per Kommandos über
eine bidrektionale serielle Verbindung. Zum Aktivieren dieser Funktion siehe
bitte UI_SERIAL_COMMANDS im Abschnitt "misc settings" in config.h. Das Verhalten
des Testers ändert sich etwas. Die Automatisierung erwingt den Auto-Hold-Modus,
und der Tester sucht nach dem Einschalten nicht automatisch nach einem Bauteil. 

Die Kommandoschnitstelle ist recht einfach. Du sendest ein Komanndo und der
Tester antwortet. Die Kommunikation basiert auf ASCII-Textzeilen, und bei den
Kommandos ist auf Groß- und Kleinschreibung zu achten. Jede Kommandozeile
wird mit einem <CR><LF> oder <LF> Newline abgeschlossen. Der Tester nimmt
Kommandos nur während des Wartens auf den Benutzer nach dem Einschalten, der
Ausgabe eines Bauteils oder der Ausführung einer Menüfunktion an. Antwort-
zeilen enden mit einem <CR><LF> Newline. Für die Liste der Kommandos und
ihrer Beschreibung siehe Abschnitt "Fernsteuerungskommandos"


+ VT100-Ausgabe

Anstatt einer LCD-Anzeige kann die komplette Ausgabe über ein VT100-Terminal
erfolgen (siehe VT100 im Abschnitt LCD-Module). Um ein Durcheinander im Layout
der Ausgabe zu vemeiden, werden die anderen Optionen für die serielle Schnitt-
stelle deaktiviert.


* Einschalten

Ein langer Tastendruck beim Einschalten aktiviert den Auto-Hold-Modus. In
diesem Modus wartet der Tester nach einer Ausgabe auf einen kurzen Tastendruck,
um mit der Bauteilesuche weiter zu machen. Ansonsten läuft der Tester im
kontinuierlichen Modus. Die Auswahl des Modus läßt sich per config.h (
UI_AUTOHOLD) umdrehen. Nach dem Einschalten wird kurz die Firmwareversion
angezeigt.

Mit einem sehr langen Tastendruck (2s) beim Einschalten kannst Du die
Abgleichwerte auf ihre Standards zurück setzen. Das kann praktisch sein, wenn
z.B. der Kontrast vom LCD-Modul so verstellt ist, daß man nichts mehr sieht. 

Wenn der Tester ein Problem mit den gespeicherten Abgleichwerten entdeckt (
Problem mit dem EEPROM), zeigt er einen Prüfsummenfehler an und benutzt 
stattdessen die Firmware-Standardwerte.

Bei einem Tester mit einem manuellen Ein/Aus-Schalter statt dem Soft-Latch-
Schalter der Referenzschaltung bitte POWER_SWITCH_MANUAL in config.c
aktivieren. In diesem Fall kann sich der Tester leider nicht selbst
abschalten.


* Bauteilesuche

Nach dem Einschalten sucht Tester automatisch nach Bauteilen. Im
kontinuierlichen Modus wiederholt der Tester die Suche nach einer kurzen
Wartepause. Wenn mehrfach hintereinander kein Bauteil gefunden wurde, schaltet
sich der Tester von selbst aus. Im Auto-Hold-Modus (durch Cursor signalisiert)
führt der Tester einen Suchvorgang aus und wartet dann auf einen Tastendruck
bzw. Rechtsdrehung vom Drehencoder bevor er die nächste Suche startet.

Die Wartepause und das automatische Abschalten im kontinuierlichen Modus kann
mittels CYCLE_DELAY und CYCLE_MAX in config.h geändert werden. Für den Auto-
Hold-Modus gibt es eine optionale automatische Abschaltung (POWER_OFF_TIMEOUT),
welche nur während der Bauteilesuche und Ausgabe aktiv ist.

In beiden Modi kannst Du das Hauptmenü aufrufen (siehe weiter unten).


* Batterieüberwachung

Jeder Zyklus der Bauteilesuche beginnt mit der Anzeige der Batteriespannung
und des Status (ok, schwach, leer). Bei Unterschreiten der Schwellspannung für
eine leere Batterie schaltet sich der Tester aus. Die Batterie wird regelmäßig
während des Betriebs überprüft.

Die Standardkonfiguration der Batterieüberwachung ist für eine 9V-Batterie
ausgelegt, kann aber an fast jede andere Stromversorgung angepaßt werden. Im
Abschnitt "power management" in config.h findest Du alle Einstellungen dazu.

Die Batterieüberwachung kann mittels BAT_NONE deaktiviert werden, auf direkte
Messung für Batterien mit weniger als 5V per BAT_DIRECT konfiguriert werden,
oder auf indirekte Messung über einen Spannungsteiler (definiert durch BAT_R1
und BAT_R2) gesetzt werden. Manche Tester unterstützen zwar eine optionale
externe Stromversorgung, aber erlauben keine Überwachung dieser. In diesem
Fall kannst Du per BAT_EXT_UNMONITORED Probleme mit dem automatischen
Abschalten bei zu niedriger Batteriespannung umgehen. Bei externer Strom-
versorgung wird der Batteriestatus dann auf "ext" (für extern) gesetzt.

Die Schwellwerte für eine schwache und leere Batterie werden über BAT_WEAK
und BAT_LOW gesetzt, während BAT_OFFSET den Spannungsverlust durch die
Schaltung definiert, z.B. Verpolungsschutzdiode und PNP-Transistor zum
Schalten der Stromversorgung.


* Ausschalten

Während das Ergebnis der letzten Bauteilesuche angezeigt wird, schaltet ein
langer Tastendruck den Tester aus. Dabei zeigt der Tester ein kurzes "Auf
Wiedersehen" und schaltet sich dann selbst ab. Allerdings bleibt der Tester
solange noch eingeschaltet, wie die Taste gedrückt gehalten wird. Das liegt
am Design des Schaltungsteils der Stromversorgung. 


* Menü

Durch zweimaliges kurzes Drücken der Test-Taste nach der Ausgabe des letztes
Ergebnisses gelangt man in das Menü. Einfach zweimal kurz hintereinander drücken.
Kann vielleicht etwas Übung am Anfang benötigen ;) Wenn ein Drehencoder
vorhanden ist, startet zusätzlich eine Linksdrehung das Menü. Die alte Methode
über den Kurzschluß der drei Testpins kann ebensfalls aktiviert werden
(UI_SHORT_CIRCUIT_MENU).

Im Menü wählt ein kurzer Tastendruck den nächsten Punkt aus und ein langer
Tastendruck führt den ausgewählten Punkt aus. Bei einem LCD-Modul mit 2 Zeilen
wird unten rechts eine Navigationshilfe angezeigt. Ein ">", wenn weitere
Punkte folgen, oder ein "<" beim letzten Punkt. Geht man weiter als der letzte
Punkt, gelangt man wieder zum ersten. Bei einem LCD-Modul mit mehr als 2
Zeilen wird der ausgewählte Punkt mit einem "*" davor gekennzeichnet.

Ist ein Drehencoder vorhanden, wird mit dem Drehen der vorherige bzw. nächste
Punkt augewählt. Hier gibt es auch wieder einen Überlauf, d.h. vom ersten zum
letzten Punkt. Ein kurzer Tastendruck führt den Punkt aus, im Gegensatz zu
oben.

Manche Punkte/Extras zeigen beim Start das Pinout der benutzten Testpins kurz
an. Die Info wird für ein paar Sekunden gezeigt, kann aber mit einem kurzen
Tastendruck übersprungen werden.

Funktionen, welche Signale erzeugen, geben ihr Signal standardmäßig auf
Testpin #2 aus. Dabei werden die Pins #1 und #3 auf Masse gesetzt. Ist Dein
Tester für die Signalausgabe auf einem eigenen Ausgang (OC1B) konfiguriert, 
werden die Testpins nicht genutzt und es erfolgt auch keine Ausgabe des
Pinout.


+ PWM-Generator

Macht genaus das, was Du erwartest. :) Vor dem Übersetzen der Firmware bitte
entweder den PWN-Generator mit einfacher Bedienung oder den mit erweiterter
Bedienung auswählen. Letzterer benötigt einen Drehencoder und ein größeres
Display. Für die optionale Ausgabe der Pulsdauer zusätzlich PWM_SHOW_DURATION
aktivieren.

Beschaltung bei Signalsusgabe über die Testpins: 
  Pin #2:          Ausgang (680 Ohm Widerstand zur Strombegrenzung)
  Pin #1 und #3:   Masse


- Einfache PWM

Zuerst muß man aus einer vorgegeben Liste die Frequenz wählen. Kurzer Tasten-
druck für die nächste Frequenz und langer Tastendruck zum Starten, wie beim
Menü. Mit Drehencoder ein kurzer Tastendruck zum Starten.

Das Tastverhältnis startet bei 50% und kann in 5%-Schritten geändert werden.
Ein kurzer Tastendruck für +5% und ein langer für -5%. Zum Beenden die Test-
Taste zweimal kurz hintereinander drücken.

Ist ein Drehencoder vorhanden, läßt sich das Tastverhältnis in 1%-Schritten
ändern.


- Erweiterte PWM

Mit einem kurzen Tastendruck schaltest Du zwischen Frequenz und Tastverhältnis
um. Der ausgewählte Wert wird durch ein Sternchen markiert. Mit dem Dreh-
encoder änderst Du den Wert, rechts für höher, links für niedriger. Und mit
einem langen Tastendruck wird auf den Standardwert zurück gestellt (Frequenz:
1kHz, Tastverhältnis: 50%). Mit zwei kurzen Tastendrücken wird der PWM-
Generator beendet.


+ Rechteck-Signalgenerator

Der Signalgenerator gibt ein Rechtecksignal mit variabler Frequenz bis zu
einem 1/4 des MCU-Taktes aus (2MHz bei 8MHz Takt). Die Startfrequenz liegt
bei 1000Hz und kann mit dem Drehencoder geändert werden. Die Dreh-
geschwindigkeit bestimmt den Grad der Änderung, d.h. langsames Drehen ergibt
kleine Änderungen und schnelles Drehen große. Da die Signalerzeugung auf
der internen PWM-Funktion der MCU basiert, können nicht beliebige Frequenzen
generiert werden, sondern nur in Schritten. Für niedrige Frequenzen ist die
Schrittweite recht klein, erst bei hohen Frequenzen wird sie signifikant.
Ein langer Tastendruck stellt die Frequenz zurück auf 1kHz und zwei kurze
Tastendrücke beenden den Signalgenerator.

Beschaltung bei Signalsusgabe über die Testpins:
  Pin #2:          Ausgang (680 Ohm Widerstand zur Strombegrenzung)
  Pin #1 und #3:   Masse

Hinweis: Drehencoder oder andere EIngabeoption notwendig!


+ Zenertest (Hardware-Option)

Mit Hilfe eines DC-DC-Konverters wird eine Testspannung von bis zu 50V zum
Testen von Zenerdioden generiert. Der Anschluß erfolgt über zusätzliche
Testpins. Solange die Test-Taste gedrückt wird, erzeugt der Konverter die
Testspannung und die aktuelle Spannung wird angezeigt. Nach dem Loslassen
der Taste wird die kleinste gemessene Spannung angezeigt, sofern der Test
ausreichend lange für eine stabile Testspannung lief. Dieser Vorgang kann
beliebig oft wiederholt werden. Zum Beenden die Test-Taste zweimal kurz
hintereinander drücken.

Wenn Dein Tester nur den 10:1 Spannungsteiler ohne Boost-Konverter zum
Messen einer externen Spannung hat, oder der Boost-Konverter ständig läuft,
kannst Du den alternativen Modus (ZENER_UNSWITCHED) aktivieren, welcher
die Spannung periodisch ohne Drücken der Test-Taste misst. Zeigt der Tester
zwischen den Messungen unten rechts einen Cursor an, kannst Du den Zenertest 
über zweimaliges Drücken der Test-Taste beenden. Als weitere Option kannst Du
den Zenertest auch während der normalen Bauteilesuche automatisch laufen
lassen (HW_PROBE_ZENER). Wird kein Bauteil an den normalen Testpins gefunden,
prüft der Tester die Spannung an den Zener-Testpins.

Für den Fall, dass Dein Tester einen Nicht-Standard-Spannungsteiler hat (nicht
10:1), aktiviere ZENER_DIVIDER_CUSTOM und setze die Widerstandswerte (ZENER_R1
und ZENER_R2).

Beschaltung für Zenerdiode:
   Pin +: Kathode
   Pin -: Anode


+ ESR-Tool

Das ESR-Tool kann den Kondensator in der Schaltung messen und zeigt
neben der Kapazität den ESR an, wenn ein Kondensator tatsächlich entdeckt
wird. Stelle sicher, daß der Kondenstor vor dem Anschließen entladen wurde!
Die gemessenen Werte können von einer Messung außerhalb der Schaltung wegen
parallel geschalteter Bauteile abweichen.

Um die Messung zu starten, kurz die Test-Taste drücken. Zum Beenden die
Test-Taste zweimal kurz hintereinander drücken.

Beschaltung für Kondensator:
   Pin #1:  Plus
   Pin #3:  Minus


+ Kondensatorleckstrom

Der Test auf Leckstrom lädt einen Kondensator auf und zeigt dabei den Strom
und die Spannung über den Messwiderstand an. Das Laden beginnt mit Rl (680 Ohm)
und schaltet auf Rh (470kOhm) um, sobald der Strom einen bestimmten Grenzwert
unterschreitet.

Jeder Testzyklus beginnt mit der Anzeige der Belegung der Testpins. Nach dem
Verbinden des Kondensators startet ein Druck der Testtaste das Laden (oder
Rechtsdrehung bei einem Drehencoder). Ein weiterer Druck beendet das Laden,
und der Tester entlädt den Kondensator während die Restspannung angezeigt wird.
Sobald der Entladegrenzwert erreicht ist, startet der Tester einen neuen
Testzyklus. Zum Verlassen des Tests zweimal kurz die Testtaste drücken.

Hinweis: Auf Polarität von Elkos achten!

Beschaltung für Kondensator:
   Pin #1:  Plus
   Pin #3:  Minus


+ R/C/L-Monitore

Die Monitorfunktionen messen ständig passive Bauteile an den Testpins #1 und
#3. Nach dem Starten zeigt der Tester die Beschaltung der Testpins für ein paar
Sekunden an, was durch die Testtaste übersprungen werden kann.

Zwischen den Messungen gibt es jeweils eine kurze Pause von einer oder zwei
Sekunden, die durch einen Cursor unten rechts signalisiert wird. Während der
Pause lässt sich der Monitor durch zwei kurze Tastendrücke (Testtaste)
beenden.

Verfügbare Monitore:
- R-Monitor (Widerstand)
- C-Monitor (Kapazität plus optional ESR)
- L-Monitor (Induktivität)
- R/C/L-Monitor (R plus optional L, oder C plus optional ESR)
- R/L-Monitor (Widerstand plus optional Induktivität)


+ L/C-Meter (Hardware-Option)

Das L/C-Meter basiert auf einer einfachen LC-Oszillatorschaltung, welche von
mehreren preiswerten PIC-L/C-Metern benutzt wird. Das übliche Design (82µH und
1nF) hat eine Grundfrequenz von etwa 595 kHz, und das Verbinden eines
zusätzlichen Kondensators oder einer Induktivität veringert diese Frequenz.
Mit der Hilfe von einen Referenzkondensator mit bekanntem Wert, den gemessenen
Frequenzen und etwas Mathematik kann der Wert des unbekannten Kondensators bzw.
Induktivität berechnet werden.

Die PIC-L/C-Meter haben in der Regel einen Messbereich von 10nH bis 100mH,
und 0.1pF bis 900nF. Sie scheinen eine Torzeit von 100ms für den Frequenz-
zähler zu nutzen. Die m-Firmware hat dagegen eine automatische Bereichswahl
mit Torzeiten von 100ms und 1000ms, um die Auflösung für kleine L/C-Werte zu
verbessern. Somit starten die Messbereiche bei ca. 1nH und 10fF (0.01pF). Die
maximal messbare Induktivität ist grob 150mH. Bzgl. der Kapazität bin ich bei
der Schaltung auf ein Problem mit dem Ausgangssignal ab ca. 33nF gestoßen.
Dort bekommen die Flanken kleine Sporne, wodurch der Frequenzzähler mehr
Pulse sieht als wirklich da sind. Ein Benutzer erwähnte, dass es sich um ein
bekanntes Problem der LM311-basierten Oszilatorschaltung handelt. Beim Testen
mehrerer Modifikationen ergab sich keine nennenswerte Verbesserung. Daher
scheint ein weiterer Komparator oder ein Logik-Gatter mit Schmitt-Trigger-
Eingang die beste Lösung zu sein, um das Ausgangssignal des Oszillators zu
bereinigen. Das CMOS Vierfach-NAND 4093 funktioniert dazu prima. Bei einem
sauberen Ausgangssignal liegt das Maximum der Kapazität bei ca. 120nF (darüber
wird der LC-Oszillator instabil). Der Tester begrenzt die Messungen auf einen 
unteren Wert von 10kHz, d.h. die theoretischen Maximalwerte sind 250mH bzw.
3,5µF, wenn der LC-Oszillator stabil liefe.

Nach dem Starten vom L/C-Meter führt der Tester als Erstes einen Selbst-
abgleich durch, angezeigt durch eine "abgleichen..." Nachricht. Danach
kann der Kondensator oder die Spule zum Messen verbunden werden. Ein kurzer
Tastendruch schaltet zwischen C und L-Messung um (Standard: C-Messung). Die
Frequenz des LC-Oszillators driftet mit der Zeit etwas (bis zu 100 Hz) und
benötigt dann einen erneuten Abgleich. Wenn Du einen größer werdenden Null-
Wert oder ein "-" ohne angeklemmtem Bauteil siehst, bitte den Selbstabgleich
über einen langen Tastendruck starten. Falls es ein Problem mit dem Abgleich
gibt oder er durch einen Tastendruck abgebrochen wird, verläßt der Tester das
L/C-Meter und gibt einen Fehler aus. Zwei kurze Tastendrücke beenden das
L/C-Meter.

Hinweise:
- Der Referenzkondensator sollte ein 1nF-Folientyp mit kleiner Toleranz sein.
  Du kannst aber auch einen üblichen Folienkondensator um die 1nF nehmen, ihn
  mit einem guten LCR-Meter messen, und LC_METER_C_REF entsprechend ändern.
- Wenn Dich die Frequenz des LC-Oszillators und ihr Driften interessiert, dann
  aktiviere LC_METER_SHOW_FREQ.


+ Frequenzzähler (Hardware-Option)

Den Frequenzzähler gibt es in zwei Versionen. Der Einfache besteht aus einem
passiven Eingang für den T0-Pin der MCU. Und der Erweiterte hat neben einem
Eingangspuffer auch zwei Oszillatoren zum Testen von Quartzen (für niedrige
und hohe Frequenzen) und einen zusätzlichen Frequenzvorteiler. Beide
Schaltungen sind in der Dokumentation von Karl-Heinz beschrieben.


- Einfacher Zähler

Ist die Zusatzschaltung für den einfachen Frequenzzähler eingebaut, kannst Du
damit Frequenzen von ca. 10Hz bis zu 1/4 der MCU-Taktfrequenz mit einer
Auflösung von 1Hz bei Frequenzen unterhalb von 10kHz messen. Die Frequenz wird
ständig gemessen und angezeigt, bis Du die Messung durch zwei kurze Tasten-
drücke beendest. Die automatische Bereichswahl setzt die Torzeit auf Werte
zwischen 10ms und 1000ms, je nach Frequenz. Der T0-Pin kann parallel zum 
Ansteuern einer Anzeige verwendet werden.


- Erweiterter Zähler

Der erweiterte Frequenzzähler hat einen zusätzlichen Vorteiler, welcher die
Messung höherer Frequenzen erlaubt. Das theoretische Maximum liegt bei 
1/4 des MCU-Taktes multipliziert mit dem Vorteiler (16:1 or 32:1). Die Steuer-
signale werden in config_<mcu>.h definiert, und bitte nicht vergessen, in
config.h den korrekten Vorteiler auszuwählen.

Der Signaleingang (gepufferter Eingang, Quartz-Oszillator für niedrige
Frequenzen, Quartz-Oszillator für hohe Frequenzen) wird über die Testtaste oder
den Drehencoder geändert. Zwei kurze Tastendrücke beenden den Frequenzzähler.


+ Ereigniszähler (Hardware-Option)

Der Ereigniszähler nutzt den T0-Pin als festen Eingang und reagiert auf die
steigend Flanke eines Signals. Der T0-Pin kann nicht parallel zum Ansteuern
einer Anzeige verwendet werden. Eine einfache Eingangsstufe wird empfohlen.

Der Zähler wird über ein kleines Menü gesteuert, welches auch die Zählerwerte
anzeigt. Die Menüpunkte werden über einen kurzen Tastendruck ausgewählt, und
die Einstellungen über den Drehencoder oder zusätzliche Tasten geändert. Der
erste Menüpunkt ist der Zählermodus:

  - Zählen      zähle Zeit und Ereignisse
  - Zeit        zähle Ereignisse für eine vorgegebene Zeit
  - Ereignisse  zähle Zeit für eine vorgegebene Anzahl von Ereignissen

Der zweite Menüpunkt "n" ist die Anzahl der Ereignisse. Im Zählermodus
"Ereignisse" wird der Stopwert angezeigt, welcher geändert werden kann. Ein
langer Tastendruck stelt den Stopwert auf einen Vorgabewert (100). In anderen
Zählermodi ist dieser Menüpunkt blockiert. Der nächste Menüpunkt "t" ist
die Zeitperiode in Sekunden (Vorgebwert: 60s). Gleiches Spiel, nur für den
Zeit-Modus. Und der letzte Menüpunkt startet oder stoppt den Zähler über
einen langen Tastendruck. Während der Zähler läuft, werden die Anzahl der
Ereignisse und die vergangene Zeit jede Sekunde aktualisiert, und nach dem
Stoppen die Ergebnisse angezeigt.

Der Grenzwert für die Zeit ist 43200s (12h) und für die Ereignisse 4*10^9.
Sobald einer der Grenzwerte überschritten wird, stoppt der Zähler automatisch.
Der Grenz- oder Stopwert für Ereignisse wird alle 200ms überprüft. Daher ist
bei mehr als 5 Ereignissen/s ein Übersteigen des Wertes möglich.


- Triggerausgang

Optional kannst Du den Triggerausgang aktivieren (EVENT_COUNTER_TRIGGER_OUT),
um ein anderes Gerät über die Testpins zu steuern. Der Triggerausgang wird
während des Zählens auf High gesetzt, d.h. steigende Flanke beim Start und
fallende Flanke bei Stop.

Beschaltung für Triggerausgang über die Testpins: 
  Pin #1:      Masse
  Pin #2:      Ausgang (680 Ohm Widerstand zur Strombegrenzung)
  Pin #3:      Masse


+ Drehencoder

Diese Funktion testet Drehencoder und bestimmt das Pinout. Deine Aufgabe ist
es, die Testpins an den Drehencoder (A, B, Common) anzuschließen und den
Encoder nach rechts (also Uhrzeigersinn) zu drehen. Der Algorithmus benötigt
4 Grey-Code-Schritte zur Erkennung. Die Drehrichtung ist wichtig zur Erkennung
von A und B, da eine falsche Richtung zur Verdrehung der Pins führen würde. 

Wenn ein Drehencoder entdeckt wird, gibt der Tester die Pinbelegung aus und
wartet auf einen Tastendruck beim Auto-Hold-Modus oder wartet kurz beim
kontinuierlichen Modus. Zum Beenden die Test-Taste kurz während eines
Suchlaufs drücken.


+ Kontrast

Für manche grafische LCD-Module kannst Du den Kontrast einstellen. Ein kurzer
Tastendruck erhöht den Wert, ein langer verkleinert ihn. Zum Beenden die
Test-Taste zweimal kurz hintereinander drücken. Ist ein Drehencoder
vorhanden, kann der Kontrastwert damit ebenfalls geändert werden. 


+ Detektor/Decoder für IR-Fernbedienungen

Diese Funktion erkennt und dekodiert Signale von IR-Fernbedienungen und
benötigt ein IR-Empfängermodul, wie z.B. aus der TSOP-Serie. Beim Übersetzen
der Firmware kannst Du zwischen zwei Anschlussvarianten wählen. Bei der ersten
Variante wird das Moduls mit den normalen Testpins verbunden. Die zweite
Variante ist ein festes Modul, welches mit einem bestimmten MCU-Pin verbunden
ist.

Wenn ein bekanntes Protokoll erkannt wird, gibt der Tester das Protokoll,
Adresse (sofern verfügbar), Kommando und ggf. zusätzliche Informationen
hexadezimal aus. Das Ausgabeformat ist:
  <Protokoll> <Datenfeld(er)>

Bei einem defekten Datenpaket wird "?" als Datenfeld ausgegeben.

Ist das Protokoll unbekannt, zeigt der Tester die Anzahl der Pausen & Pulse
und die Dauer des ersten Puls und der ersten Pause in Einheiten von 50µs an:
  ? <Pulse>:<erster Pulse>-<erste Pause>

Wenn die Anzahl der Pulse bei verschiedenen Tasten der Fernbedienung gleich
bleit, ist die Modulation sehr wahrscheinlich PDM oder PWM. Eine sich
ändernde Anzahl von Pulsen weist auf Bi-Phase-Modulation hin. 

Zum Beenden die Test-Taste einmal kurz drücken.

Unterstützte Protokolle und ihre Datenfelder:

  - JVC
    <Addresse>:<Kommando>

  - Kaseikyo (Japancode, 48 Bit)
    <Herstellercode>:<System>-<Produkt>:<Funktion>

  - Matsushita (Panasonic MN6014, C6D6 / 12 bits)
    <Gerätecode>:<Datencode>

  - Motorola
    <Kommando>

  - NEC (Standard & Erweitert)
    <Addresse>:<Kommando>
    R für Wiederholsequenz

  - Proton / Mitsubishi (M50560)
    <Addresse>:<Kommando>

  - RC-5 (Standard)
    <Addresse>:<Kommando>

  - RC-6 (Standard)
    <Addresse>:<Kommando>

  - Samsung / Toshiba (32 Bit)
    <Gerätecode>:<Datencode>

  - Sharp
    <Addresse>:<Kommando>

  - Sony SIRC (12, 15 & 20 Bit)
    12 & 15: <Kommando>:<Addresse>
    20:      <Kommando>:<Addresse>:<Erweitert>

Optionale Protokolle (SW_IR_RX_EXTRA):

  - IR60 (SDA2008/MC14497)
    <Kommando>

  - Matsushita (Panasonic MN6014, C5D6 / 11 bits)
    <Gerätecode>:<Datencode>

  - NEC µPD1986C
    <Datencode>

  - RECS80 (Standard & Erweitert)
    <Addresse>:<Kommando>

  - RCA
    <Addresse>:<Kommando>

  - Sanyo (LC7461)
    <Gerätecode>:<Taste>

  - Thomson
    <Gerät>:<Funktion>

Die Trägerfrequenz vom TSOP IR-Empfängermodul muß nicht genau zur Fernsteuerung
passen. Es verringert sich eigentlich nur die Reichweite, was für unseren Zweck
aber kein Problem darstellt.


- IR-Empfängermodul an Testpins

Das IR-Empfängermodul bitte erst im IR-Fernbedienungsdetektor anschliessen!

Beschaltung für das TSOP-Modul:
  Probe #1:  Masse/Gnd
  Probe #2:  Vs (680 Ohm Widerstand zur Strombegrenzung)
  Probe #3:  Data/Out

Hinweis:
  Der Widerstand zur Strombegrenzung setzt ein IR-Empfängermodul mit einem
  Versorgungsspannungsbereich von ca. 2,5 - 5V voraus. Wenn Du ein 5V-Modul
  hast, kannst Du in config.h den Widerstand auf eigene Gefahr abschalten.
  Ein Kurzschluss kann allerdings die MCU zerstören.


- Festes IR-Empfängermodul

Für das feste Modul bitte Port und Daten-Pin in config_<MCU>.h passend setzen.


+ IR-Fernbedienung

Die IR-Fernbedienung sendet Fernbedienungscodes, welche Du zuvor eingegeben
hast, und dient zum Testen von IR-Empfängern bzw. von Geräten mit IR-
Fernbedienung. Diese Funktion benötigt eine zusätzliche Eingabeoption, wie
z.B. ein Drehencoder, ein Display mit mehr als vier Textzeilen und eine
einfache Treiberschaltung für die IR-LED.

Der Tester zeigt Dir das Protokoll, die Trägerfrequencz, das Tastverhältnis
des Trägers und ein paar Datenfelder. Mit einem kurzen Druck der Test-Taste
schaltest Du zwischen den Punkten hin und her. Der ausgewählte Punkt wird
durch ein "*" gekennzeichnet. Über den Drehencoder (oder andere Eingabeoption)
änderst Du die Einstellung bzw. den Wert eines Punktes.  Bei einem langen
Druck der Test-Taste sendet der Tester den IR-Code solange die Test-Taste
gedrückt bleibt. Und wie üblich beenden zwei kurze Tastendrücke die Funktion.

Wenn Du das Protokoll änderst, werden Trägerfrequenz und Tastverhältnis auf
die Standardwerte des jeweiligen Protokolls gesetzt. Du kannst diese aber
nach Belieben ändern. Die Trägerfrequenz kann auf 30 bis 56 kHz gestellt
werden, und das Tastverhältnis auf  1/2 (50%), 1/3 (33%) oder 1/4 (25%). Die
Datenfelder sind die Teile des Fernbedienungscodes, die Du setzen kannst. Sie
werden weiter unten erklärt und sind meistens nur die Adresse und das Kommando.

Unterstützte Protokolle und ihre Datenfelder:

  - JVC
    <Adresse:8> <Kommando:8>

  - Kaseikyo (Japanese Code)
    <Hersteller:16> <System:4> <Produkt:8> <Funktion:8>

  - Matsushita (Panasonic, MN6014 12 bits)
    <Gerät:6> <Taste:6>

  - Motorola
    <Kommando:9>

  - NEC Standard
    <Adresse:8> <Kommando:8>

  - NEC Extended
    <Adresse:16)> <Kommando:8>

  - Proton / Mitsubishi (M50560)
    <Adresse:8> <Kommando:8> 

  - RC-5 Standard
    <Adresse:5> <Kommando:6>

  - RC-6 Standard, Mode 0
    <Adresse:8> <Kommando:8>

  - Samsung / Toshiba (32 bits)
    <Gerät:8> <Taste:8>

  - Sharp / Denon
    <Adresse:5> <Kommando:8> <Maskierung:1>

  - Sony SIRC-12
    <Kommando:7> <Adresse:5>

  - Sony SIRC-15
    <Kommando:7> <Adresse:8>

  - Sony SIRC-20
    <Kommando:7> <Adresse:5> <Erweitert:8>

Optionale Protokolle (SW_IR_RX_EXTRA):

  - Thomson
    <Gerät:4> <Funktion:7>

Die Datenfelder sind durch Leerzeichen getrennt und ihre Syntax ist:
  <Feldname>:<Anzahl Bits>

Beschaltung bei Signalsusgabe über die Testpins:
  Pin #2:          Signalausgang (680 Ohm Widerstand zur Strombegrenzung)
  Pin #1 und #3:   Masse

Der Signalausgang (Test-Pin #2) hat einen Widerstand zur Strombegrenzung und
kann eine IR-LED mit nur etwa 5mA direkt schalten, was für eine typische IR-LED
mit einem If von 100mA nicht ausreichend ist. Daher wird ein einfacher Treiber
auf Basis eines Transistors, der IR-LED und einem Widerstand zur Strom-
begrenzung benötigt.

Beispielschaltung für einen Treiber, welcher die IR-LED (Vf 1.5V, If 100mA) mit
50mA schaltet:

                           + +5V
                           |
                           |
                           -
                          | |
                       75 | |
                          | |
                           -
                           |
                           |
                          ___ ->
                   IR LED \ / ->
                          ---
                           |
                           | C
              -----    B |/
  Signal ----| 3k9 |-----|  NPN
              -----      |\
                           | E
                    BC548  |
                           |
                           - Gnd

Hinweis:
  Falls das Timing der Pulse/Pausen nicht passen sollte, bitte die alternative
  Warteschleifenmethode SW_IR_TX_ALTDELAY aktivieren. Dies ist notwendig, wenn
  der C-Compiler die Standardwarteschleife trotz Anweisung, den Inline-
  Assembler-Code beizubehalten, optimiert.


+ Opto-Koppler-Test

Dieser Test prüft Opto-Koppler und gibt V_f der LED, den CTR-Wert (auch If)
und t_on bzw. t_off Zeiten (für Transistortypen) aus. Unterstützt werden
Standard-NPN-Transistoren, NPN-Darlington-Stufen und TRIACs. Für die CTR-
Messung wird der I/O-Pin der MCU kurzzeitig für ca. 3ms überlastet. Das
Datenblatt gibt einen maximalen Ausgangsstrom vom 20mA an, wir überlasten
den Pin aber bis zu ca. 100mA. Daher ist der maximale CTR-Wert begrenzt, und
Werte über 2000% sollte man mit Vorsicht geniessen.

Der maximale Strom für die LED ist 5mA, was bei TRIAC-Typen zu beachten ist.
Relais-Typen (MOSFET back to back) werden als Transistor erkannt und der
CTR-Wert ist dann bedeutungslos. Typen mit anti-parallelen LEDs werden
ignoriert.

Zum Testen brauchst Du einen einfachen Adapter mit folgenden drei Testpunkten:

Transistor-Typ:
- Anode der LED
- Kathode der LED und Emitter vom Transistor miteinander verbunden
- Kollektor vom Transistor

TRIAC-Typ:
- Anode der LED
- Kathode der LED und MT1 vom TRIAC miteinander verbunden
- MT1 vom TRIAC

Du kannst den Adapter nach Belieben mit den drei Testpins vom Tester
verbinden. Der Tester findet die Anschlußbelegung dann automatisch.

Nach dem Starten bitte den Adapter mit den Testpins vom Tester verbinden und
kurz die Taste zum Prüfen drücken. Wenn ein Opto-Koppler gefunden wurde, zeigt
der Tester den Typen und verschiedene Infos an. Wurde keiner erkannt, erfolgt
die Anzeige von "keiner". Ein blinkender Cursor weist darauf hin, daß ein
Tastendruck für die nächste Prüfung erwartet wird. Zwei kurze Testendrücke
beenden, wie üblich, den Test.


+ Modellbau-Servo-Test

Diese Funktion erzeugt ein PWM-Signal für Modellbau-Servos, welche mit einem
1-2 ms PWM-Puls gesteuert werden. Die typischen PWM-Frequenzen von 50, 125,
250 und 333Hz werden unterstützt, und die Pulselänge ist im Bereich von 0,5
bis 2,5 ms einstellbar. Zusätzlich gibt es einen Sweep-Modus für Pulse
von 1 - 2ms und wählbarer Geschwindigkeit. 

Die Pulsbreite stellst Du mit dem Drehencoder ein. Links für kürzere Pulse,
und rechts für längere. Mit einem langen Tastendruck wird die Pulsweite auf
1,5ms zurück gesetzt (mittlere Position vom Servo).

Mit einem kurzen Tastendruck wechselst Du zwischen Puls- und Frequenzauswahl (
durch ein Sternchen markiert). In der Frequenzauswahl schaltest Du mit dem
Drehencoder zwischen den Frequenzen um. Mit einem langen Tastendruck wird der
Sweep-Modus ein- bzw. ausgeschaltet (durch ein "<->" markiert).

Solange der Sweep-Modus eingeschaltet ist, wird die Pulslänge durch die
Sweep-Zeit ersetzt, welche mittels dem Drehencoder geändert werden kann.

Wie üblich beenden zwei kurze Tastendrücke die Funktion.

Beschaltung bei Signalsusgabe über die Testpins:
  Pin #2:          PWM-Ausgang (680 Ohm Widerstand zur Strombegrenzung)
  Pin #1 und #3:   Masse

Hinweis: Für den Servo benötigst Du eine zusätzliche Stromversorgung.

Pinbelegungen für typische 3-Pin-Servo-Stecker:

Hersteller     Pin 1               Pin 2               Pin 3
---------------------------------------------------------------------- 
Airtronics     PWM weiss/schwarz   Gnd schwarz         Vcc rot
Futaba         PWM weiss           Vcc rot             Gnd schwarz
hitec          PWM gelb            Vcc rot             Gnd schwarz
JR Radios      PWM orange          Vcc rot             Gnd braun


+ OneWire-Scan

Der OneWire-Scan zeigt die ROM-Codes all angeschlossenen Busteilnehmer an.
Zum Einrichten des OneWire-Busses siehe bitte den Abschnitt "Busse &
Schnittstellen". Bei Benutzung der Test-Pins informiert der Tester über die
Beschaltung und wartet bis ein externer Pull-Up-Widerstand erkannt wurde.
Mit einem Tastendruck läßt sich dies überspringen.

Bei jedem Tastendruck sucht der Tester nach dem nächsten Busteilnehmer und
gibt dessen ROM-Code aus (in hexadezimal). Der erste Teil der Ausgabe ist der
Familiencode und der zweite die Seriennummer. Der CRC-Wert wird weggelassen.
Bei einem Familiencode >= 0x80 (Bit 7 gesetzt) handelt es sich um einen
kundenspezifischen Code, und die oberen (linken) drei Stellen der Seriennummer
sind die Kunden-ID.

Der Tester informiert Dich, wenn er den letzten Busteilnemher gefunden hat,
bzw. bei CRC- oder Busfehlern. Im Fall des letzten Busteilnehmers oder eines
Busfehlers kannst Du per Tastendruck einen komplett neuen Scandurchlauf
starten. Wie üblich beenden zwei kurze Tastendrücke die Funktion. 


+ DS18B20-Temperatursensor

Hiermit wird der OneWire-Temperatursensor DS18B20 ausgelesen. Zum Einrichten
des OneWire-Busses siehe bitte den Abschnitt "Busse & Schnittstellen". Bei
Benutzung der Test-Pins informiert der Tester über die Beschaltung und wartet
dann bis ein externer Pull-Up-Widerstand erkannt wurde. Mit einem Tastendruck
läßt sich dies überspringen.

Nach den Verbinden des DS18B20 als einziger Client am Bus startet ein Tasten-
druck das Auslesen der Temperatur (kann fast eine Sekunde dauen). Zum Beenden
zweimal kurz die Test-Taste drücken. Und mit einem langen Tastendruck wählst
Du den Auto-Modus (automatische Aktualisierung), welcher durch ein "*" in der
ersten Zeile signalisert wird.

Beschaltung von Test-Pins:
  Probe #1:  Gnd
  Probe #2:  DQ (Daten)
  Probe #3:  Vcc (Strom durch 680 Ohm Widerstand begrenzt)
  Ein externer Pull-Up-Widerstand von 4,7kOhm zwischen DQ and Vcc wird
  benötigt!


+ DHTxx-Sensoren

Zum Lesen von DHT11, DHT22 und kompatiblen Temperatur & Luftfeuchte-Sensoren.
Zuerst zeigt der Tester die Beschaltung der Test-Pins und wartet auf den
externen Pull-Up-Widerstand. Danach wird der ausgewählte Sensortyp angezeigt (
Standard: DHT11), welcher durch einen kurzen Druck der Testtaste gelesen wird. 
Bei erfolgreichem Lesen gibt der Tester die Messwerte aus, bei einem Fehler
nur ein "-". Ein langer Tastendruck ändert den Sensortypen, und zwei kurze
Tastendrücke beenden die Funktion. Beim Ändern des Sensortyps hast Du die
Möglichkeit, den automatischen Lesemodus (jede Sekunde) zu aktivieren. Dieser
wird durch ein "*" nach dem Sensornamen signalisiert.

Unterstützte Sensoren:
  DHT11: DHT11, RHT01
  DHT22: DHT22, RHT03, AM2302
         DHT21, RHT02, AM2301, HM2301
         DHT33, RHT04, AM2303
         DHT44, RHT05

Beschaltung von Test-Pins:
  Probe #1:  Gnd
  Probe #2:  Data
  Probe #3:  Vdd (Strom nicht begrenzt)

Ein externer Pull-Up-Widerstand von 4,7kOhm zwischen Data and Vdd wird benötigt!
Manche Sensormodule haben bereits einen 10kOhm Pull-Up-Widerstand integriert,
welcher ebenfalls gut mit kürzeren Kabeln funktioniert.


Hinweis:
  Wegen des Strombedarfs des Sensor kann der 680 Ohm Testwiderstand nicht
  zur Strombegrenzung genutzt werden. Also Vorsicht, ein Kurzschluss kann
  die MCU beschädigen.


+ Selbsttest

Wenn Du den Selbsttest über das Menü gestartet hast, bittet dich der Tester
die drei Testpins kurz zu schließen und wartet solange, bis er dies erkennt.
Bei Problemen kannst Du das Warten mit einem Tastendruck abbrechen.

Der Selbsttest führt jeden Test 5-mal aus. Mit einem kurzen Tastendruck wird
der aktuelle Test übersprungen, mit einem langen Tastendruck der komplette
Test.

In Test #4 ist der Kurzschluß wieder zu entfernen. Der Tester wartet dann
so lange.

Die Testschritte sind:
- T1 interne Spannungsreferenz (in mV)
- T2 Vergleich der Rl-Widerstände (Offset in mV)
- T3 Vergleich der Rh-Widerstände (Offset in mV)
- T4 Entfernen des Kurzschlusses der Testpins/kabel
- T5 Leckstromtest für Testpins mit Gnd-Pegel (Spannung in mV)
- T6 Leckstromtest für Testpins mit Vcc-Pegel (Spannung in mV)


+ Selbstabgleich

Der Selbstabgleich misst den Widerstand und die Kapazität der Messkabel, d.h.
von Platine, interner Verkabelung und dem Messkabel als Summe, um einen
Nulloffset zu bestimmen. Auch wird der interne Widerstand der MCU-Portpins
im Pull-Up und Pull-Down Modus bestimmt. Wenn der Abgleich übersprungen wird 
oder unplausible Werte gemessen werden, werden die Standardwerte der Firmware
angenommen. Wenn alles sauber durch läuft, werden die neuen Werte angezeigt,
aber nicht automatisch im EEPROM gespeichert (siehe Speichern/Laden).

Der Spannungsoffset des Analogkomparators wird automatisch bei der Messung
eines Kondensators bestimmt (bei der normalen Bauteilesuche), wenn der
Kondensator einen Wert zwischen 100nF und 3,3µF hat. Außerdem wird
gleichzeitig der Offset der internen Spannungsreferenz gemessen.

Bevor der Selbstabgleich ausgeführt wird, solltest Du einen Folienkondensator
mit einer Kapazität zwischen 100nF und 3,3µF min. 3-mal messen, damit die oben
erwähnten Offsets bestimmt werden können. Typischerweise liefert die erste
Messung einen zu niedrigen Wert, die zweite einen zu hohen und erst die dritte
eine korrekten Wert. Das wird durch die sich selbst abgleichenden Offsets
verursacht.

Mit einem festen Kondensator zum Selbstabgleich wird der automatische Abgleich
in der Kapazitätsmessung durch eine eigene Funktion ersetzt, welche während
des Selbstabgleichs ausgeführt wird. Somit brauchst Du nicht mehr vorher
einen Folienkondensator zu messen.

Falls der Kapazitätsoffset zwischen den Test-Pin-Paaren zu sehr variiert,
kannst Du in config.h auf spezifische Offsets je Test-Pin-Paar umschalten (
CAP_MULTIOFFSET). Das Gleiche ist für den Widerstandsoffset möglich (
R_MULTIOFFSET). 

Der Selbstabgleich ist dem Selbsttest vom Ablauf und der Bedienung her sehr
ähnlich.

Die Schritte des Selbstabgleichs sind:
- A1 Offsets für interne Spannungsreferenz und Analogkomparator
     (nur bei festem Abgleichkondensator)
- A2 Widerstand der Testpins/kabel (in 10mOhm)
- A3 Entfernen des Kurzschlusses der Testpins/kabel
- A4 interner Widerstand der Portspins für Gnd (Spannung über RiL)
- A5 interner Widerstand der Portspins für Vcc (Spannung über RiH)
- A6 Kapazität der Testpins/kabel (in pF)

Erlaubte Maximalwerte:
- Widerstand Testpin/Kabel < 1,50 Ohm (zwei in Reihe)
- Kapazität Testpin/Kabel < 100pF

Hinweis: Wenn der Widerstandswerte der Testpins zu sehr variieren, könnte ein
Kontaktproblem vorliegen.

Merke: Abgleich ist nicht Kalibrierung! Kalibrierung ist die Prozedur, 
Messergebnisse mit verfolgbaren Standards zu vergleichen und die Abweichungen
zu notieren. Der Zweck ist die Überwachung der Abweichungen über die Zeit. Der
Abgleich ist die Prozedur, ein Messgerät so einzustellen, daß es seine
Vorgaben bzgl. Genauigkeit und anderer Parameter einhält.


+ Speichern/Laden

Nach dem Selbstabgleich kannst mit dieser Funktion die im EEPROM gespeicherten
Abgleichswerte aktualisieren. Beim nächsten Neustart vom Tester werden dann
diese Werte (Profil #1) automatisch geladen und benutzt.

Zur Bequemlichkeit stehen zwei Profile zum Speichern bzw. Laden zu Verfügung,
z.B. für zwei unterschiedliche Sätze an Messkabeln.

Die Idee hinter der manuellen Speichern-Funktion ist, daß man z.B. beim
temporären Wechsel der Messkabel nur einen Selbstabgleich macht und nach
dem Neustart wieder die Werte für die Haupt-Messkabel hat. Ansonsten müsste
man für die alten Kabel wieder einen neuen Selbstabgleich machen.

Als Option kannst Du das Lade-Menü automatisch nach dem Einschalten des
Testers anzeigen lassen (UI_CHOOSE_PROFILE).


+ Werte anzeigen

Diese Funktion zeigt die aktuellen Abgleichwerte an. Die Nutzung einer
externen 2.5V Spannungsreferenz wird mit einem "*" nach Vcc signalisiert.


+ Ausschalten

Hiermit kannst Du den Tester abschalten, sofern die Funktion über SW_POWER_OFF
aktiviert wurde.


+ Exit

Damit kannst Du das Menü verlassen, wenn Du z.B. aus Versehen reingegangen
bist.


* Widerstände

Widerstände werden zweimal gemessen. d.h. in beide Richtungen, und die Werte
dann verglichen. Wenn die Werte zu unterschiedlich sind, nimmt der Tester an,
daß es zwei Widerstände sind und nicht nur einer. In dem Fall zeigt die
Ausgabe zwei Widerstände mit gleichen Pins in der Form "1 -- 2 -- 1" mit den
beiden Werten an. Für Widerstände kleiner als 10 Ohm wird eine zusätzliche
Messung mit höherer Auflösung durchgeführt. 

In seltenen Fällen kann der Tester sehr kleine Widerstände nicht erkennen. Am
besten dann die Messung einfach wiederholen. 

Wenn die optionale Prüfung auf E-Normwerte (SW_R_E*) aktiviert ist, nimmt
der Tester den nächst kleineren und nächst größeren Normwert, und vergleicht
diese mit dem gemessenen Widerstand unter Berücksichtigung der Bauteiltoleranz.
Es gibt zwei Ausgabemodi. Im Text-Modus gibt der Tester die E-Serie plus
Toleranz und passende Normwerte aus. Ein "-" bedeutet, dass kein Normwert
passt. Im Farbcode-Modus zeigt der Tester die E-Serie und den Farbcode des
Normwertes inklusive Farbband für die Toleranz. Die Farben können je nach
Displaymodul und Farbkombinationen unterschiedlich ausfallen. Falls eine Farbe
danebenliegt, einfach den Farbwert (COLOR_CODE_*) in der Datei colors.h
entsprechend ändern. Eine Internetsuche nach "RGB565 tool" listet viele
Online-Tools zum Auswählen der RGB565-Farbwerte. 


* Kondensatoren

Die Messung von Kondensatoren ist in drei Methoden aufgeteilt. Große
Kondensatoren >47µF werden mittels Ladezyklenmethode mit Pulsen von 10ms
gemessen. Mittelgroße zwischen 4,7µF and 47µF werden ebenfalls mit der
Ladezyklenmethode gemessen, aber mit Pulsen von 1ms. Kleine Kondensatoren
laufen über den analogen Komparator. Auf dies Weise wird die Genauigkeit der
Kapazitätsmessung optimiert. 

Die Messwerte großer Kondensatoren benötigen eine eine Korrektur. Ohne
Korrektur wären die Werte zu hoch. Ich denke, daß dies durch die Messmethode
verursacht wird, da die Analog-Digital-Wandlung nach dem Ladepuls eine gewisse
Zeit benötigt und der Kondensator in dieser Zeit etwas Ladung durch Leckströme
verliert und natürlich auch durch die Analog-Digital-Wandlung selber. So dauert
es dann länger bis der Kondensator geladen ist, und die Kapazität erscheint
höher. Eine spätere Selbstentlademessung versucht dies zu kompensieren, kann es
aber nur teilweise. Die Korrekturfaktoren (CAP_FACTOR_SMALL, CAP_FACTOR_MID
und CAP_FACTOR_LARGE in config.c) sind so gewählt, daß sie für die meisten
Testermodelle passen. In manchen Fällen kann aber eine Änderung notwendig sein. 

Eine Logik zum Verhindern, daß große Kondensatoren als Widerstände erkannt
werden, wurde hinzugefügt. Widerstände kleiner als 10 Ohm werden zusätzlich
auf Kapazität geprüft.

Der Tester versucht den ESR bei Kondensatoren größer als 18nF zu messen.
Alternativ kannst Du auch die alte Messmethode aktivieren, welche ab 180nF
mißt. Da aber die Messung nicht per Wechselstrom mit einer bestimmten Frequenz
durchgefüghrt wird, bitte keine supergenauen Ergebnisse erwarten. Die benutzte
Methode entspricht vielleicht der Messung mit 1kHz. Für die Prüfung von Elkos
ist die Messung mehr als ausreichend. Bei Filmkondensatoren mit kleinen Werten,
können je nach MCU-Taktrate unterschiedliche Werte zustande kommen. Ich denke,
Herr Fourier könnte dies erklären.

Ein gemessener Kapazitätswert von mehr als 5pF (incl. Nulloffset) wird
als gültig angesehen. Niedrigere Werte sind zu ungenau und könnten durch
Verschiedenes, wie z.B. anderes Platzieren der Messkabel, verursacht werden.

Eine weitere Messung ist der Selbstentladungsleckstrom für Kodensatoren größer
als 4,7µF. Der Wert gibt z.B. einen Hinweis auf den Zustand eines Elkos.
Von meinen Tests her scheinen folgende Werte typisch für Elkos zu sein:  
  - 10-220µF    1-3µA
  - 330-470µF   4-5µA
  - 470-820µF   4-7µA
  - >1000µF     5-7µA pro 1000µF

Die optionale Prüfung auf E-Normwerte gibt es ebenfalls für Kondensatoren (
SW_C_E*), aber nur im Text-Modus, da es einfach zu viele unterschiedliche
Farbcodes für Kondensatoren gibt.


* Induktivitäten

Die Induktivitätsmessung ist nicht sonderlich genau, und Dinge wie z.B. der
MCU-Takt und die Platine haben Auswirkungen auf das Ergebnis. Die Messung
selber basiert auf der Bestimmung der Zeit zwischen dem Einschalten des
Stroms und dem Erreichen eines bestimmten Stroms. Für große Induktivitäten
gibt es eine Niedrigstrommessung, und für kleine Induktivitäten eine Hoch-
strommessung, welche das Stromlimit der MCU-Pins kurzzeitig überschreitet (bis
zu etwa 25 Microsekunden).

Bei der Untersuchung der Effekte des MCU-Takts und anderer Dinge habe ich ein
Muster an Abweichungen gefunden, welches zum Kompensieren genutzt werden kann.
Je nach Tester kann eine Anpassung notwendig sein. In der Datei inductance.c
in der Funktion MeasureInductor() gibt es die Variable "Offset" zur
Kompensation. Sie ist ein Offset für die Referenzspannung. Ein positiver
Wert verkleinert die Induktivität, und ein negativer Wert vergrößert die
Induktivität.

Die Kompensation für die Hochstrommessung basiert auf den MCU-Takt und ist in
drei Zeitbereiche unterteilt. Für die Niedrigstrommessung gibt es momentan nur
eine einfache Kompensation, da hier noch weitere Tests notwendig sind. Wenn Du
größere Abweichungen beim Vergleich mit einem richtigen LCR-Meter siehst,
kannst Du die Offsetwerte entsprechend deinem Tester anpassen.

Wenn Du eine Prüfung auf E-Normwerte möchtest, bitte die SW_L_E*-Schalter
in config.h aktivieren (nur Text-Modus).

Hinweise:
- Bei unerwarteten Messwerten bitte die Messung wiederholen.
- Die Induktivitätsmessung wird nur durchgeführt, wenn der Widerstand der
  Spule kleiner als 2k Ohm ist.


* Bauteile entladen

Der Tester versucht vor und während des Messens das angeschlossene Bauteil
zu entladen. Wenn er das Bauteil nicht auf einen vorgegebenen Nullwert (
CAP_DISCHARGED) entladen kann, gibt er einen Fehler mit Angabe des Testpins
und der Restspannung aus. Im Fall einer Battery entspricht die angezeigte
Spannung nicht der Batteriespannung.

Die Entladefunktion basiert nicht auf einem festen Timeout, sondern paßt
sich automatisch dem Entladefortschritt an. Auf diese Weise wird eine
Batterie schneller erkannt und große Kondensatoren erhalten mehr Zeit zum
Entladen. Sollte ein großer Elko als Batterie erkannt werden, bitte nochmal
versuchen. In einer Umgebung mit vielen elektrischen Störungen könnte auch
der Nullwert CAP_DISCHARGED mit 2mV zu niedrig sein (ggf. anpassen). Die
anzeigte Restspannung hilft beim Finden des optimalen Nullwertes.


* ADC Oversampling

Die ADC-Funktion unterstützt ein variables Oversampling (1 - 255). Der
Standardwert ist 25 Samples. Du kannst versuchen, durch Erhöhen des
Oversamplingwerts die Genauigkeit des Testers zu erhöhen. Allerdings
steigt mit einem höheren Wert auch die benötigte Zeit, d.h. die Messungen
werden langsamer.


* Ergebnisanzeige

Einige Namen und Abkürzungen wurden geändert. Die Ausgabe mancher Bauteile
wird auf mehrere Seiten aufgeteilt, wenn das LCD-Modul nicht ausreichend viele
Zeilen hat.

Bei einer einzelnen Diode wird das Vf der Messung mit niedrigem Teststrom (
10µA) in Klammern angezeigt, wenn der Wert unter 250mV liegt. Damit erhält man
einen Hinweis auf eine Germaniumdiode. Die meisten Datenblätter von Germanium-
dioden geben einen Messtrom von 0,1mA für Vf an. Leider unterstützt der Tester
nicht diesen Messstrom. Und für höhere Ströme liegt Vf bei etwa 0,7V, was eine
Unterscheidung zu Siliziumdioden schwierig macht. 

Der Leckstrom I_R für eine einzelne Diode bzw. I_CEO für einen Bipolar-
Transistor wird ausgegeben, sofern er höher als 50nA ist. Germanium-
transistoren haben einen Leckstrom im Bereich von wenigen µA bis etwa 500µA.
Germaniumdioden liegen üblicherweise bei ein paar µA.

Für manche Bauteile wird ein Kapazitätswert angezeigt. Liegt die Kapazität
unterhalb von 5pF oder die Messung schlug fehl, wird 0pF ausgegeben.

Wenn ein Verarmungs-FET mit symmetrischem Drain und Source gefunden wird,
zeigt die Pinbelegung ein 'x' statt 'D' oder 'S', da beide vom Tester nicht
unterschieden werden können, sie sind funktional identisch. In diesem Fall
bitte im Datenblatt nach Details der Pinbelegung schauen.

Die Pinbelegung eines TRIAC wird mit den Pins 'G', '1' and '2'. angezeigt.
'1' ist MT1 und '2' ist MT2. Und für einen UJT, sofern die Erkennung aktiviert
ist, ist es '1' für B1, '2' für B2 und 'E' für den Emitter.

Wenn die "Fancy Pinout" Funktion aktiviert wurde (über das Setzen einer
Symboldatei in config.h), wird das Bauteilesymbol mit den entsprechenden
Testpins für 3-Pin-Halbleiter angezeigt. Sollte nicht genügend Platz auf dem
Display sein, wird die Ausgabe des Symbols übersprungen.


+ Zusätzliche Hinweise


Bipolartransistoren

Ein Kleinbuchstabe hinter dem hFE-Wert zeigt den Typ der Testschaltung an,
die zum Messen benutzt wurde:
  - e: Emitterschaltung
  - c: Kollectorschaltung

Wenn Du die Ausgabe vom hFE-Teststrom aktiviert hast (SW_HFE_CURRENT), dann
zeigt der Tester I_C für die Emitterschaltung und I_E für die Kollector-
schaltung.

Beim Test auf Dioden wird Vf zum einen mit Rl (hoher Teststrom) und zum
anderen mit Rh (niedriger Teststrom) gemessen. Die Ausgabefunktion für
Bipolartransistoren interpoliert aus den beiden Vf-Werten V_BE abhängig vom
hFE für einen virtuellen Teststrom. Somit erhält man praxisnahe Werte, da V_BE
eines Kleinsignaltransistors mit einem anderen Strom gemessen wird als bei
einem Leistungstransistor.

Bei einem Bipolartransistor mit Basis-Emitter-Widerstand wird der Widerstand
angezeigt. Beachte, dass der B-E-Widerstand Einfluss auf V_BE und hFE hat.
Wenn der Transistor zusätzlich eine Schutzdiode hat, kann er als Transistor
oder zwei Dioden erkannt werden, je nach Wert des Basis-Emitter-Widerstands.
Im letzteren Fall werden zwei Dioden plus Widerstand mit dem Hinweis auf einen
möglichen Transistor angezeigt. Ein niedriger Basis-Emitter-Widerstand
verhindert leider die eindeutige Erkennung des Transistors.

Ein weiterer Spezialfall ist ein Bipolartransistor mit integrierter
Schutzdiode, die sich auf dem gleichen Substrat befindet. Der integrierte
PN-Übergang erzeugt einen parasitären zweiten Transistor. Ein NPN bekommt
somit einen paristären PNP und umgekehrt. Wird ein solcher Transistor
entdeckt, wird er mit einem "+" hinter der Typenangabe gekennzeichnet.

Bei einem Schottky-Transistor (Schottky-clamped BJT) wird die Schottky-
Diode zwischen Basis und Kollektor incl. V_f angezeigt, sofern die Erkennung
aktiviert ist (SW_SCHOTTKY_BJT). Es sei darauf hingewiesen, dass I_CEO bei
einem Schottky-Transistor erhöht ist.


TRIACs

TRIACs werden in drei bzw. vier Modi, auch als Quadranten bekannt, betrieben.
Typischerweise unterscheiden sich manche Parameter je nach Quadrant, wie z.B.
der Triggerstrom I_GT. In manchen Fällen passiert es, daß der Teststrom vom
Tester ausreichend ist, den TRIAC in einem Quadranten zu triggern, aber nicht
in einem anderen. Da der Tester zwei Testläufe benötigt, um die Pins für MT1
und MT2 zu bestimmen, kann der Tester in solchen Fällen die Pins nicht
unterscheiden, d.h. sie könnten vertauscht sein.

Manche TRIACs können vom Tester getriggert werden, haben aber einen zu hohen
Haltestrom (I_H), wodurch sie nicht korrekt erkannt werden können. Wenn bei
einem TRIAC der Triggerstom zu hoch für den Tester ist, wird er meistens
als Widerstand erkannt.


CLDs

Die Diodenprüfung erkennt eine CLD (Current Limiting Diode) als normale Diode
und gibt ihren Strom I_F als Leckstrom aus. Zu beachten ist, daß bei einer CLD
Anode und Kathode gegenüber einer normalen Diode vertauscht sind. Eine
gesonderte Erkennung von CLDs ist schwierig, da der Leckstrom einer Germanium
oder Leistungs-Schottky-Diode im Bereich von I_F (ab ca. 33µA) liegt.

Wenn eine Diode ein ungewöhnliches V_f hat, ein niedriges V_f beim Niedrig-
stromtest (zweiter Wert in Klammern) und keine Kapazität gemessen werden
konnte, dann ist es wahrscheinlich eine CLD.


* Nicht unterstütze Bauelemente

Alle Halbleiter, welche einen hohen Steuerstrom oder eine hohe Steuerspannung
benötigen, können nicht erkannt werden, da der Tester max. ca. 7mA Strom und
5V Spannung zum Schalten hat. So kann z.B. ein DIAC mit einem V_BO von 20-200V
nicht getestet werden. Das gleiche für Thyristoren and TRIACs mit hohem
Triggerstrom.


* Abhilfen für manche Tester

Wenn Dein Tester eines der folgenden Probleme zeigt, kannst Du ein Worksround
versuchen:

- hFE viel zu hoch 

  Problem:
  Bei der Kollektorschaltung mit Rl als Basiswiderstand wird aus unbekanntem
  Grund die Basisspannung zu niedrig gemessen. Somit erscheint der Basisstrom
  ebenfalls niedriger und verursacht einen zu hohen hFE-Wert. 

  Betroffene Tester:
  Hiland M644

  Abhilfe:
  Aktiviere NO_HFE_C_RL in config.h!


* Bekannte Probleme

- Ein Speicher- bzw. Superkondensator, wie z.B. Panasonic NF Serie, wird als
  Diode oder zwei anti-parallele Dioden erkannt. Die Kapazitätsmessung
  kann keinen brauchbaren Wert bestimmen.
- Bei Verwendung eines Schaltnetzteiles oder DC-DC-Konverters zur Strom-
  versorgung gibt der Tester manchmal fälschlicherweise einen Elko um
  die 50µF aus, obwohl kein Bauteil angeschlossen ist.
- Der ESR kann bei Kondensatoren mit 180 - 220nF je nach MCU-Takt
  variieren.
- Problem mit der ESR-Messung bei low-ESR Elkos mit festem Elektrolyt. 


* Hilfe

Hilfe findest Du in folgenden zwei Foren:
- https://www.mikrocontroller.net/topic/248078
  Hauptsprache ist Deutsch, Englisch ist aber auch ok.
- https://www.eevblog.com/forum/testgear/$20-lcr-esr-transistor-checker-project/
  Nur Englisch.


* Firmware-Änderungen

Bitte die Datei CHANGES.de lesen!


* Fernsteuerungskommandos

Wenn der Tester ein Kommando akzeptiert, antwortet er mit spezifischen Daten
oder einem der folgenden Standardtexte: 

  ERR
  - unbekanntes Kommando
  - Kommando im aktuellen Komponentenkontext nicht unterstützt
  - Pufferüberlauf

  OK
  - Kommando ausgeführt
    (manche Kommandos benötigen etwas Zeit zum Ausführen)

  N/A
  - Information/Wert nicht verfügbar

Antworten mit Daten beginnen nie mit einem der obigen Standardtexte, um
mögliche Unklarheiten zu vermeiden.


Basiskommandos:

  VER
  - gibt Version der Firmware zurück
  - to verify connectivity and to determine command set based on version
  - Beispielantwort: "1.33m"

  OFF
  - schaltet den Tester aus
  - Tester anwortet mit "OK" vor dem Auschalten
  - Beispielantwort: "OK" <Tester schaltet ab>


Testkommandos:

  PROBE
  - sucht nach Bauteil und überspringt alle Pausen für Benutzereingaben
  - Tester antwortet mit einem "OK" nach dem Beenden der Suche
  - Beispielantwort: <some time elapses for probing> "OK"

  COMP
  - gibt ID der Bauteilart zurück
  - für IDs siehe COMP_* in common.h
  - Beispielantwort für BJT: "30"

  MSG
  - gibt Fehlermeldung zurück
  - nur falls ein Fehler aufgetreten ist (COMP: 1)
  - Antwort kann von der Sprache des Benutzerinterfaces abhängen
  - Beispielantwort: "Battery? 1:1500mV"

  QTY
  - gibt Anzahl der gefundenen Bauteile zurück
  - Beispielantwort für BJT: "1"

  NEXT
  - wählt zweites Bauteil aus
  - nur wenn zwei Bauteile gefunden wurden (QTY: 2)
  - Beispielantwort: "OK"

  TYPE
  - gibt den Typen eines Bauteils zurück
  - nur für BJT, FET und IGBT
  - verfügbare Typen:
    - NPN      NPN (BJT)
    - PNP      PNP (BJT)
    - JFET     JFET (FET)
    - MOSFET   MOSFET (FET)
    - N-ch     n-Kanal (FET, IGBT)
    - P-ch     p-Kanal (FET, IGBT)
    - enh.     Anreicherungstyp (FET, IGBT)
    - dep.     Verarmungstyp (FET, IGBT)
  - Beispielantwort für BJT: "NPN"
  - Beispielantwort für FET (MOSFET): "MOSFET n-ch enh."

  HINT
  - gibt Hinweise zu speziellen Merkmalen eines Bauteils zurück
  - nur für Diode, BJT, FET und IGBT
  - verfügbare Merkmale:
    - NPN      möglicherweise ein NPN BJT (Diode)
    - PNP      möglicherweise ein PNP BJT (Diode)
    - R_BE     Basis-Emitter-Widerstand (Diode, BJT)
    - BJT+     integrierte Freilaufdiode auf gleichem Substrat
               erzeugt parasitären zweiten BJT (BJT)
    - D_FB     Body/Freilauf-Diode (BJT, FET, IGBT)
    - D_CLAMP  Schottky-Transistor (BJT)
               benötigt aktivierte Schottky-Transistor-Erkennung
    - SYM      Drain und Source symmetrisch (FET) 
  - Beispielantwort für BJT: "D_FB R_BE"
  - Beispielantwort für FET (MOSFET): "D_FB"

  MHINT
  - giobt Hinweise zu Messungen zurück
  - nur für BJT
  - verfügbare Merkmale:
    - h_FE_e   h_FE-Messung mit Emitterschaltung (BJT)
    - h_FE_c   h_FE-Messung mit Kollektorschaltung (BJT)
  - Beispielantwort für BJT: "h_FE_e"

  PIN
  - gibt Anschlußbelegung zurück
  - benutzte Kennungen:
    - Widerstand   x = verbunden, - = nicht verbunden
    - Kondensator  x = verbunden, - = nicht verbunden
    - Diode        A = Anode, C = Kathode, - = nicht verbunden
    - BJT          B = Basis, C = Kollektor, E = Emitter
    - FET          G = Gate, S = Source, D = Drain, x = Drain/Source
    - IGBT         G = Gate, C = Kollektor, E = Emitter
    - SCR          G = Gate, A = Anode, C = Kathode
    - TRIAC        G = Gate, 2 = MT2, 1 = MT1
    - PUT          G = Gate, A = Anode, C = Kathode
    - UJT          E = Emitter, 2 = B2, 1 = B1
  - Format der Antwort:
    <Test-Pin #1 Kennung><Test-Pin #2 Kennung><Test-Pin #3 Kennung>
  - Beispielantwort für Widerstand: "xx-"
  - Beispielantwort für Diode: "C-A"
  - Beispielantwort für BJT: "EBC"

  R
  - gibt Widerstandswert zurück
  - nur für Widerstand (beinhaltet auch Induktiviät)
  - Beispielantwort: "122R"

  C
  - gibt Kapazitätswert zurück
  - nur für Kondensator
  - example responses: "98nF" "462uF"

  L
  - gibt Induktiviätswert zurück
  - nur für Widerstand (beinhaltet auch Induktiviät)
  - Beispielantwort: "115uH"

  ESR
  - gibt ESR-Wert zurück (Equivalent Series Resistance)
  - benötigt aktivierte ESR-Messung
  - nur für Kondensator
  - Beispielantwort: "0.21R"

  I_l
  - gibt I_leak zurück (Leckstromequivalent zur Selbstentladung)
  - nur für Kondensator
  - Beispielantwort: "3.25uA"

  V_F
  - gibt V_F zurück (forward voltage)
  - nur für Diode und PUT
  - auch für Body-Diode von MOSFET und Freilaufdiode von BJT oder IGBT
  - Beispielantwort: "654mV"

  V_F2
  - gibt V_F der Niedrigstrommessung zurück (forward voltage)
  - nur für Diode
  - Beispielantwort: "387mV"

  C_D
  - gibt C_D zurück (Kapazität der Diode)
  - nur für Diode
  - Beispielantwort: "8pF"

  I_R
  - gibt I_R zurück (reverse current)
  - nur für Diode
  - Beispielantwort: "4.89uA"

  R_BE
  - gibt R_BE zurück (Basis-Emitter-Widerstand)
  - nur für Diode und BJT
  - Beispielantworten: "38.2R" "5171R"

  h_FE
  - gibt h_FE zurück (DC-Stromverstärkungsfaktor)
  - nur für BJT
  - Beispielantwort: "234"

  h_FE_r
  - gibt den umgekehrten h_FE zurück (Kollektor und Emitter verdreht)
  - nur für BJT
  - Beispielantwort: "23"

  I_C
  - gibt den Teststrom I_C der hFE-Messung zurück
  - benötigt aktivierte Ausgabe des Teststroms der hFE-Messung
  - für hFE-Messung mit Emitterschaltung
  - nur für BJT
  - Beispielantwort: "3245uA"

  I_E
  - gibt den Teststrom I_E der hFE-Messung zurück
  - benötigt aktivierte Ausgabe des Teststroms der hFE-Messung
  - für hFE-Messung mit Kollektorschaltung
  - nur für BJT
  - Beispielantwort: "3245uA"

  V_BE
  - gibt V_BE zurück (Basis-Emitter-Spannung)
  - nur für BJT
  - Beispielantwort: "657mV"

  I_CEO
  - gibt I_CEO rurück (Kollektor-Emitter-Strom, offene Basis)
  - nur für BJT
  - Beispielantwort: "460.0uA"

  V_th
  - gibt V_th zurück (threshold voltage)
  - nur für FET (MOSFET) und IGBT
  - Beispielantwort: "2959mV"

  C_GS
  - gibt C_GS zurück (Gate-Source-Kapazität)
  - nur für FET (MOSFET)
  - Beispielantwort: "3200pF"

  R_DS
  - gibt R_DS_on zurück (Drain-Source-Widerstand durchgeschaltet)
  - nur für FET (MOSFET)
  - Beispielantwort: "1.20R"

  V_GS_off
  - gibt V_GS(off) zurück (Cutoff Spannung)
  - nur für Verarmungstyp-FET
  - Beispielantwort: "-3072mV"

  I_DSS
  - gibt I_DSS zurück (Drain-Source-Strom, kurzgeschlossenes Gate)
  - nur für Verarmungstyp-FET
  - Beispielantwort: "6430µA"

  C_GE
  - gibt C_GE zurück (Gate-Emitter-Kapazität)
  - nur für IGBT
  - Beispielantwort: "724pF"

  V_GT
  - gibt V_GT zurück (Gate-Trigger-Spannung)
  - nur für Thyristor und TRIAC
  - Beispielantwort: "865mV"

  V_T
  - gibt V_T zurück (Offset-Spannung)
  - nur für PUT
  - Beispielantwort: "699mV"

  R_BB
  - gibt R_BB zurück (interbase resistance)
  - benötigt aktivierte UJT-Erkennung
  - nur für UJT
  - Beispielantwort: "4758R"

  V_Z
  - gibt V_Z zurück (Zener- oder externe Spannung)
  - benötigt aktvierten Zener-Test während normaler Bauteilesuche
  - nur für Zenerdiode oder externe Spannung (Hardware-Option)
  - Beispielantwort: "6750mV"


* Hilfreiche Links

- Deutsches Forum
  https://www.mikrocontroller.net/topic/248078

- Englisches Forum
  https://www.eevblog.com/forum/testgear/$20-lcr-esr-transistor-checker-project/

- Russisches Forum
  https://vrtp.ru/index.php?showtopic=16451

- Infos zu verschiedenen Clonen, wie Bilder, Schaltpläne und Firmware
  (von indman@EEVblog)
  https://yadi.sk/d/yW8xa5NJgUo5z

- Anleitung plus div. Dateien für WinAVR (von indman@EEVblog)
  https://drive.google.com/file/d/1-IJA8uTcsCA_6SYHEuMydjfS2vNgmwdH/view?usp=sharing


* Quellenverzeichnis

[1] AVR-Transistortester, Markus Frejek,
    Embedded Projects Journal, 2011-11

[2] http://www.mikrocontroller.net/topic/131804
    Forum von Markus Frejek, Forum, 2009

[3] http://www.mikrocontroller.net/articles/AVR-Transistortester
    Online-Dokumentation des Transistortesters, Online-Artikel, 2009-2011

[4] http://www.mikrocontroller.net/articles/AVR_Transistortester
    Kurze Beschreibung des TransistorTesters, Karl-Heinz Kübbeler,
    Online-Artikel, 2012



------------------------------------ EOF -------------------------------------
