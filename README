
------------------------------------------------------------------------------

                   ReadMe for the Component Tester firmware

        (c) 2012-2013 by Markus Reschke (madires@theca-tabellaria.de)

------------------------------------------------------------------------------

Last edit:  2013-07-06


* About

The Component Tester is based on the project of Markus Frejek [1&2] and the
successor of Karl-Heinz Kübbeler [3&4]. It's an alternative software for the
current circuit by Karl-Heinz and offers some changes in the user interface
and the methods used for probing and measuring. While Karl-Heinz provides an
official release supporting most ATmega MCUs this is a playground version
with all features enabled and limited to ATmega168/P and ATmega328/P due to
memory and flash size contraints. The UI languages currently supported are
just English and German, but can be changed or extended easily.

Since the firmware's size exceeds 16kB Flash some features are only enabled
for the ATmega328/P:
- inductance measurement


* Safety Advice

The Component Tester is no DMM! It's a simple tester for components capable
of measuring several things. The probes aren't protected in any way and
won't survive higher voltages than 5V. Don't use the tester for live circuits!
Just use it for unsoldered electronic components! If you test a capacitor make
sure it's discharged before connecting the probes. This isn't just the Safety
Sally, your life may be at risk if you connect the probes to a live circuit
or a power supply (or even mains). 


* Whats different?

Karl-Heinz has done a really great documentation of the tester. I recommend
to read it. Therefore I'll tell you just about the differences to the
official release.


* Building the firmware

First edit the Makefile to specify your MCU model, frequency, oscilator
type and programmer settings. All other settings moved to config.h.

In config.h please choose the language for the UI and change any defaults
if required. All defaults are explained in the file, so I won't discuss
them here.


* Source Code

A lot of cleaning up was done, like more remarks, renamed variables,
re-structured functions, large functions splitted up into several smaller
ones and what have you. I hope the code is easy to read and maintain now.


* Test Key

The test key starts the tester and also controls the user interface. For that
purpose the tester differentiates between a short and a long key press (0.3s).
The short key press is typically used to proceed with something or to select
a menu item. The long key press performs a context specific action.   

If the tester expects you to press a key it will tell you that by displaying
a cursor at the last position in the second row of the LCD (bottom right).
A steady cursor signals that another information will be displayed and a
blinking cursor informs you that the tester will resume the probing loop. The
cursor is supressed for menus and the PWM tool, because it's obvious that
a key press is neccessary.  


* Startup

A long key press while starting the tester selects the auto-hold mode. In that
mode the tester waits for a short key press after displaying a result before
it continues. Otherwise the tester chooses the continous (looping) mode by
default. After powering on the tester displays the mode selected.

After that the tester may display a checksum error, when it loads the saved
adjustment values from the EEPROM and detects an error. That error indicates
a corrupted EEPROM, i.e. caused by too much write operations. In that case
the default adjustment values from config.h will be used.


* Probing Loop 

While displaying the result of the last test a long key press powers the
tester off. The tester will display a short goodbye message and then power
off. As long as you press the key the tester stays powered on and displays the
message. That is caused by the implementaion of the power control circuit.


* Menu

By short-circuiting all three probes you'll trigger a menu which allows you
to select some special functions (see below). A short key press shows the
the next item in the menu and a long key press selects the shown item. At the 
right side you'll see a '>' if another items follows or a '<' if the last
item is reached (will roll over to the first menu item). 

You can also enter the menu by two short key presses after the display of the
last component found (also signaled by a blinking cursor in auto-hold mode).
Simply press the test key twice quickly (might need some practice :-).


+ PWM Tool

This does what you would expect :-) First you have to select the desired PWM
frequency in a simple menu. Short key press for the next frequency and a long
key press starts the PWM output for the shown frequency.

The duty ratio of the PWM starts at 50%. A short key press of the test button
increases the ratio by 5%, a long key press decreases the ratio by 5%. To exit
the PWM tool press the test key twice quickly.

Configuration of the probes:

  Probe #2:         PWM output (with 680 Ohms resistor to limit current)
  Probe #1 and #3:  Ground


+ Selftest

The selftest function runs each test just 5 times. You can skip a test by a
short key press or skip the entire selfttest by a long key press.

In test #4 you have to remove the short circuit of the probes which triggered
the selftest mode. The tester will wait until you really removed the short
circuit.


+ Self Adjustment

The self adjustment measures the resistance and the capacitance of the probe
leads, e.g. the PCB, internal wiring and probe leads as a sum, for creating
a zero offset. It also measures the internal resistance of the MCU port pins
in pull-down and pull-up mode. If the tests are skipped or strange values are
measured the default values defined in config.h are used. If everything went
fine the tester will display and use the new values gained by the self
adjustment (they will be not stored in the EEPROM, see "Save" below).

The voltage offset of the analog comparator is automatically adjusted in the
capacitance measurement (in normal probing mode, outside of the self
adjustment) if the capacitor is in the range of 100nF up to 20µF. Also the
offset of the internal bandgap reference is determined in the same way. Both
offsets are displayed at the end of the self adjustment.

Expected limits:
- probe resistance   < 1.00 Ohms for two probes in series
- probe capacitance  < 100pF

Remember: Adjustment is not calibration! Calibration is the procedure to
compare measurement results with a known traceable standard and noting the
differences. The goal is to monitor the drift over time. Adjustment is the
procedure to adjust a device to meet specific specs.


+ Save

By flashing the firmware the pre-defined values given in config.h are stored
in the EEPROM of the MCU. After running the self adjustment you may update
those default values using the the "Save" function. The next time you power
on the tester the updated values will be loaded and used.

If you run the tester the first time or changed the hardware setup, i.e. using
other probe leads, I recommend to measure a capacitor (100nF - 2µF) to trigger
the voltage offset adjustments first. In some situations you might need to
repeat that two or three times. Then run the self adjustment and save the new
values.

The idea of the save function is to prevent automatic saving of adjustment
values. If you need to use other probe leads for some tests, you'll simply
adjust the tester for the temporary probe leads and perform the tests. If you
switch back to the standard probe leads you don't need to re-adjust because
the old values are still stored. Just powercycle the tester.


+ Show Values

This displays the current adjustments values and offsets used. 


* Resistors

Resistors are measured twice (both directions) and the values are compared.
If the values differ too much the tester assumes that there are two resistors
instead of just a single one. In that case the tester displays the result as
two resistors with the same pins, like "1 -- 2 -- 1", and the two different
resistance values. For resistors lower than 10 Ohms an extra measurement with
a higher resolution is performed.

In some rare cases the tester might not be able to detect a very low
resistance, since the primary measurements indicate a problem with the
validity of the results. In that case simply re-run the test.


* Measuring Capacitance

The measurement of capacitance is split into three methods. Large caps >47µF
are still measured by the charging cycle method with 10ms impulses. Mid-sized
caps between 4.7µF and 47µF are processed the same way but with 1ms charging
impulses. And small caps are still done by the analog comparator method. That
way the accuracy of the measurement of caps between 4.7µF and 47µF is
increased.

Also I found a simple correction solution for large caps. Without correction
the measured values are too large. IMHO that is caused by the measurement
method, since the ADC conversion after the charging impuls needs some time
during which the cap looses some charge due to internal resistive losses. So
it takes longer to charge the cap and the cap seems to have a larger
capacitance. A discharge measurement later on tries to compensate that, but
the capacitance is still too large. 

A logic for preventing large caps to be detected as resistors was added.
Resistors < 10 Ohms are checked for being large caps.

A measured capacitance value more than 5pF (incl. the zero offset) is
considered valid. Lower values are too uncertain and could be caused by
placing the probe leads a little bit different and things like that.


* Discharging Components

The discharge function isn't based on a fixed timeout, it adapts itself
to the discharging rate. That way a battery will be identified faster (about
2s) and large caps got more time to discharge. If a large cap is identified
as a battery please repeat the check. In a noisy environment you might need
to adjust CAP_DISCHARGED to about 3mV. The display of the remaining voltage
will help you to choose an appropriate value.


* ADC Oversampling

The ADC function is modified to support a variable oversampling (1-255 times).
The default value is 25 samples. You can try to improve the accuracy of the
measurements by increasing the number of samples. Note that more samples will
take more time resulting in slower measurements.


* Displaying Results

Several names and abbreviations are changed. The output for several devices
is splitted into multiple pages to have sufficient space to fully display all
data.

For a single diode the low current Vf (measured with 10µA) is shown in braces
if the voltage is below 250mV. That should give you a hint for germanium
diodes. Most datasheets of germanium diodes specify Vf at 0.1mA which the
tester doesn't support. At a higher current Vf is expected to be around 0.7V
which makes it hard to distinguish germanium from silicon diodes.

The leakage current I_R for a single diode or I_CEO for a BJT will be displayed
if it exeeds 1µA. Germanium BJTs got a leakage current of a few µA up to around
500µA. Germanium diodes are around a few µA usually.

For some devices the capacitance is shown also. In case the capacitance is
below 5pF or the measurement failed for some reason the value displayed
will be 0pF.

If a JFET is detected only the gate pin is shown since drain and source
can't be differentiated.


* Vf (V_BE) of BJTs

When checking for diodes Vf is measured with Rl (high test current) and Rh (
low test current), and both voltages are stored. The output function for BJTs
looks up the matching diode for V_BE and interpolates the two Vf measurements
based on the transistors hfe for a virtual test current. That way we get some
nice results for different kinds of transistors, since Vf of a small signal
BJT isn't measured with the same test current as for a power BJT.


* Unsupported Components

Any semiconductor which requires a high current to trigger conduction can't
be supported, since the tester only provides about 7mA at maximum. Also the
tester provides just a voltage of 5V, which isn't sufficient for DIACs with
a V_BO of 20-200V.


* Issues

Known issues:
- A storage cap (like Panasonic NF series) is detected as a diode or two
  anti-parallel diodes. The capacitance measurement isn't able to determine  
  an acceptable value either.


* Change Log

v1.08m 2013-07
- Since the SmallResistor() measurement can't give correct DC resistance
  values for some inductors a problem detection was added to CheckResistor()
  to keep the original high resistance measurement result.
- Added inductance measurement (ATmega328/P only)
- Minor improvements for the display of diodes and BJTs.
- Added leakage current measurement.
- Fixed problem with germanium BJTs with a high leakage current. They were
  detected as p-channel JFETs.
- Renamed some functions, clarified and added some remarks.

v1.07m 2013-06
- Optimized diode display function and added display of low current Vf.
- Improved the diode detection. Caps and resistors are excluded much better.
  Also the cap probing is skipped for diodes to speed up probing.  
- Fixed an array overflow bug in CheckResistor().
- Improved cursor display logic to tell user if another information follows
  or the probing loop is reentered.
- Improved UI of PWM tool to prevent exit by mistake (double key press
  required now).
- Added a generic menu function and adapted all menus (changed layout!).
- TestKey() provides a nice blinking cursor now.

v1.06m 2013-03
- Several minor improvements and cleanups.
- Expanded TestKey() to inform the user about an expected key press.  
- Improved TestKey() function to be more responsive for short key presses.
- Added a PWM tool to generate a PWM signal with different frequencies and
  duty ratios.
- Implemented a sleep function to reduce power usage of the tester.
  On average the power usage is nearly halfed (excluding the LCD backlight).
- Improved discharge function. If the discharge of a component fails, the
  concerned probe pin and the remaining voltage are displayed. That will help
  to detect a too low value for CAP_DISCHARGED.
- Added the capability to set error types

v1.05m 2012-11
- Moved LargeCap_table[] and SmallCap_table[] from EEPROM to flash to reduce
  EEPROM usage. The size for a German firmware exceeded the 512 bytes of an
  ATmega168s EEPROM.

v1.04m 2012-11
- Added a simple logic to the output function for diodes to prevent the
  measurement of capacitance for antiparallel diodes. 

v1.03m 2012-11
- Fixed detection problem of power diodes with high leakage current (mistaken
  for resistors).
- Fixed compiler warnings about possible uninitialized variables. That
  increased the firmware size by about 44 bytes :-(

v1.02m 2012-11
- Added upper limit for resistance of probe leads in the self adjustment
  function (1.00 Ohms).
- Selftest and adjustment functions perform a short circuit test before
  running the main part and return feedback now.
- The mainmenu gives feedback about success/failure of the selected action.

v1.01m 2012-10
- Added a checksum for adjustment values stored in the EEPROM and wrote a
  function to validate the checksum.
- Added a measurement function for small resistors (resolution: 0.01 Ohms).
- Extended self adjustment to support an auto-zero for the resistance of the
  probe leads.
- CheckResistor() runs an extra measurement for small resistors (<10 Ohms).
- Added a function to compare two scaled values. 
- Adapted several functions to support variable scaling of values.

v1.00m 2012-09
- Added a simple menu for selection of self test, self adjustment, update of
  the adjustment values in the EEPROM and display of values.
- Changed hfe from 16 bit to 32 bit value (no 65k limit anymore).

v0.99m 2012-09
- Initial public release based on Karl-Heinz' version 0.99k.



* References

[1] AVR-Transistortester, Markus Frejek,
    Embedded Projects Journal, 2011-11

[2] http://www.mikrocontroller.net/topic/131804
    thread of Markus Frejek, Forum, 2009

[3] http://www.mikrocontroller.net/articles/AVR-Transistortester
    Online documentation of the Transistortester, Online Article, 2009-2011

[4] http://www.mikrocontroller.net/articles/AVR_Transistortester
    Short description of the TransistorTester, Karl-Heinz Kübbeler,
    Online Article, 2012



------------------------------------ EOF -------------------------------------
